<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[系统上线故障之git]]></title>
      <url>%2F2016%2F06%2F23%2F%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%BA%BF%E6%95%85%E9%9A%9C%E4%B9%8Bgit%2F</url>
      <content type="text"><![CDATA[今天公司新系统上线，在执行上线脚本的时候，卡在了git这一步，出错信息如下图所示 当时以为是公司网络的问题，但是排查网络没有发现任何问题，于是就上Google上查找解决方案，万幸还是找到了，具体解决方法如下 git config --global http.postBuffer 524288000 再次执行git clone就可以顺利通过了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx中rewrite规则解析]]></title>
      <url>%2F2016%2F04%2F11%2Fnginx%E4%B8%ADrewrite%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[语法1rewrite regex replacement flag; 例如1rewrite ^/images/(.*\.jpg)$ /imgs/$1 break; 作用：假如用户访问的网址为http://www.magedu.com/images/a/b/c/1.jpg,则路径会自动转换为http://www.magedu.com/imgs/a/b/c/1.jpg；$1会引用前面括号中的内容 常用flag（标志位）有last,break,redirect,permanentlast：一旦此rewrite规则重写完成后，就不再被后面其它的rewrite规则进行处理，而是由User Agent重新对重写后的URL再一次发起请求，并从头开始执行类似的过程break：一旦此rewrite规则重写完成后，由User Agent对新的URL重新发起请求，且不再会被当前location内的任何rewrite规则所检查redirect：以302响应吗（临时重定向）返回新的URLpermanent：以301响应码（永久重定向）返回新的URL]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在nginx中开启状态页]]></title>
      <url>%2F2016%2F04%2F11%2F%E5%9C%A8nginx%E4%B8%AD%E5%BC%80%E5%90%AF%E7%8A%B6%E6%80%81%E9%A1%B5%2F</url>
      <content type="text"><![CDATA[语法 stub_status{on|off} 其仅能用于location上下文 编辑配置文件，添加如下配置 location /status{ stub_status on; allow 172.20.2.0/24; deny all; } 重新加载配置文件后，访问status页面，如下图所示 各字段含义如下Active connections: 1 表示当前所有处于打开状态的连接数 server accepts handled requests28 28 35第一个数字表示已经接受的连接，第二个数字表示已经处理过的连接，第三个表示已经处理过的请求数，在“保持连接”模式下，请求数量可能会多余连接数量 Reading: 0 Writing: 1 Waiting: 0Reading表示正处于接收请求状态的连接数；Writing表示请求已经接收完成，正处于处理请求或发送响应的过程中的连接数；Waiting表示保持连接模式且处于活动状态的连接数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为nginx配置https服务]]></title>
      <url>%2F2016%2F04%2F11%2F%E4%B8%BAnginx%E9%85%8D%E7%BD%AEhttps%E6%9C%8D%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[配置过程如下 生成私钥，生成证书签署请求并获得证书1234567891011121314151617181920212223~]# cd /etc/pki/CA/CA]# (umask 077;openssl genrsa -out private/cakey.pem 2048)CA]# openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3655You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:HALocality Name (eg, city) [Default City]:ZZOrganization Name (eg, company) [Default Company Ltd]:MageEduOrganizational Unit Name (eg, section) []:OpsCommon Name (eg, your name or your server's hostname) []:ca.magedu.comEmail Address []:caadmin@magedu.comCA]# touch serial index.txtCA]# echo 01 &gt; serial 1234567891011121314151617181920212223242526CA]# cd /application/nginxnginx]# mldir sslssl]# (umask 077;openssl genrsa -out nginx.key 1024) ssl]# openssl req -new -key nginx.key -out nginx.csr You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:HALocality Name (eg, city) [Default City]:ZZOrganization Name (eg, company) [Default Company Ltd]:MageEduOrganizational Unit Name (eg, section) []:OpsCommon Name (eg, your name or your server's hostname) []:www.magedu.comEmail Address []:webadmin@magedu.comPlease enter the following 'extra' attributesto be sent with your certificate requestA challenge password []:An optional company name []: 1ssl]# openssl ca -in nginx.csr -out nginx.crt -days 3655 编辑配置文件123456789101112131415161718server &#123; listen 443 ssl; server_name www.magedu.com; ssl_certificate /application/nginx/ssl/nginx.crt; ssl_certificate_key /application/nginx/ssl/nginx.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; root /web/host; index index.html index.htm; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx中配置基于用户的访问控制]]></title>
      <url>%2F2016%2F04%2F11%2Fnginx%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
      <content type="text"><![CDATA[编辑配置文件12345678910server &#123; listen 8080; server_name www.magedu.com; location / &#123; root /web/host; auth_basic "Only for VIP"; auth_basic_user_file /application/nginx/users/.htpasswd; &#125; &#125; 使用htpasswd命令创建用户和密码1]# htpasswd -c -m /application/nginx/users/.htpasswd tom --&gt; 创建用户tom，第一次需要使用-c选项]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx配置之路径别名]]></title>
      <url>%2F2016%2F04%2F08%2Fnginx%E9%85%8D%E7%BD%AE%E4%B9%8B%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D%2F</url>
      <content type="text"><![CDATA[alias在location段配置，用于实现定义路径别名假如有定义如下123location /images/&#123; root "/vhosts/web1";&#125; 若访问http://www.magedu.com/images/a.jpg其实访问的是/vhosts/web1/images/a.jpg 若在location设置了alias，如下所示123location /images/&#123; alias "/www/pictures"&#125; 若访问http://www.magedu.com/images/a.jpg,实际访问的地址是/www/pictures/a.jpg 注意：root表示指明路径为对应的location “/“ URL;alias表示路径映射，即location指令后定义的URL是相对于alias所指明的路径而言。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx中server_name与location匹配规则解析]]></title>
      <url>%2F2016%2F04%2F08%2FNginx%E4%B8%ADserver-name%E4%B8%8Elocation%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[server_name域名检查法则 先做精确匹配检查 左侧通配符匹配检查 *.magedu.com 右侧通配符匹配检查 mail.* 正则表达式匹配检查 ~^.*.magedu.com$ default_server location语法：location [ = | ~ | ~* | ^~ ] uri { ... } location @name { ... } 功能：允许根据用户请求的URI来匹配定义的各location；匹配到时，此请求将被相应的location配置块中的配置所处理，例如做访问控制等功能。 =：精确匹配检查~：正则表达式模式匹配检查，区分字符大小写~*：正则表达式模式匹配检查，不区分字符大小写^~：URI的前半部分匹配，不支持正则表达式 匹配的优先级由高到低为：=,^~,~,~*,不带任何符号的location 假如有一台虚拟主机定义如下123456789101112131415server&#123; listen 80; server_name www.magedu.com location / &#123; --&gt;1 root "/vhosts/web1" &#125; location /images/ &#123; --&gt;2 root "/vhosts/images"; &#125; location ~* \.php$&#123; --&gt;3 fcgipass &#125;&#125; 若用户在浏览器中输入http://www.magedu.com/bbs/index.php可以匹配1和3，而3的优先级大于1，所以会匹配3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx主配置段(main)指令详解]]></title>
      <url>%2F2016%2F04%2F08%2Fnginx%E4%B8%BB%E9%85%8D%E7%BD%AE%E6%AE%B5%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[正常运行的必备配置 user USERNAME [GROUPNAME];：指定以哪个用户或组的身份运行worker进程 pid /path/to/pid_file; 指定nginx守护进程的pid文件 worker_rlimit-nofile number;：指定所有worker进程所能够打开的最大文件句柄数 性能优化相关的配置 worker_processes number;：指明打开worker进程的个数，通常应略少于CPU物理核心数 worker_cpu_affinity cpumask …;：提升缓存的命中率但无法避免context swich对CPU带来的不必要消耗 timer_resolution：计时器解析度，降低此值可减少gettimeofday()系统调用的次数 worker_priority number;：指明worker进程的nice值（nice值范围从-20到19，数字越小优先级越高） 事件相关的配置 accept_mutex on|off; master调度用户至各worker进程时使用的负载均衡锁； on表示能让多个worker轮流地、序列化地去响应新请求 lock_file file; accept_mutex用到的锁文件路径 use method; 此处的method可选值有epoll,rtsig,select与poll，指明使用的事件模型，建议让Nginx自行选择 worker_connections number;设定单个worker进程所能够处理的最大并发连接数量 用于调试、定位问题的相关配置前提：要启用调试功能需要在编译安装时提供–with-debug选项才可以。 daemon on|off; 是否以守护进程方式来运行nginx；调试时应设置为off,其它情况下要设置为on master_process on|off; 是否以master/worker模型来运行nginx，调试时可以设置为off。 需要经常进行调整的参数主要有worker_processes,worker_connections,worker_cpu_affinity,worker_priority。 修改配置完成后需使用/usr/local/nginx/sbin/nginx -s reload命令使新配置生效。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NFS网络文件系统]]></title>
      <url>%2F2016%2F03%2F17%2FNFS%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[简介NFS是Network File System的缩写，它的主要功能是通过网络可以使不同主机系统之间共享文件。 RPC由于NFS支持的功能比较多，每启用一个功能都会随机启动一个未被占用的端口来作为传输；NFS客户端必须要确定NFS服务器端的端口才能正常传输数据，而端口又是随机的，这样就会造成NFS客户端与服务器端的通讯障碍，恰好RPC服务（即远程过程调用）就很好地解决了这个问题。RPC的作用就是记录每一个NFS功能所对应的端口号。 NFS软件要部署NFS服务，需要安装下面的软件包： nfs-utils：这是NFS服务的主程序，包括rpc.nfsd,rpc.mountd两个daemons和相关文档说明与执行命令文件等。 portmap：Centos5下面RPC的主程序（Centos6下则为rpcbind）NFS可以被视为一个RPC程序，在启动任何一个RPC程序之前，需要做好端口和功能的映射工作，这个映射工作就是由portmap或rpcbind服务来完成的。因此，在提供NFS服务之前必须先启动portmap或rpcbind服务。 安装nfs查看NFS软件的安装情况：1~]# rpm -qa nfs-utils portmap rpcbind 修改主机名：12[root@node1 ~]# hostname nfsserver[root@node2 ~]# hostname nfsclient 12[root@nfsserver ~]# yum -y install nfs-utils rpcbind[root@nfsclient ~]# yum -y install nfs-utils rpcbind 服务端启动RPC服务：12~]# /etc/init.d/rpcbind start~]# ps -ef | grep rpc rpc对外使用111端口： 12345678[root@nfsserver ~]# rpcinfo -p localhost program vers proto port service 100000 4 tcp 111 portmapper 100000 3 tcp 111 portmapper 100000 2 tcp 111 portmapper 100000 4 udp 111 portmapper 100000 3 udp 111 portmapper 100000 2 udp 111 portmapper 由于RPC服务未启动而产生的报错信息如下：12[root@nfsserver ~]# rpcinfo -p localhostrpcinfo: can't contact portmapper: RPC: Remote system error - Connection refused 启动nfs服务：1234567891011121314151617181920212223242526272829303132333435~]# /etc/init.d/nfs start[root@nfsserver ~]# rpcinfo -p localhost program vers proto port service 100000 4 tcp 111 portmapper 100000 3 tcp 111 portmapper 100000 2 tcp 111 portmapper 100000 4 udp 111 portmapper 100000 3 udp 111 portmapper 100000 2 udp 111 portmapper 100011 1 udp 875 rquotad 100011 2 udp 875 rquotad 100011 1 tcp 875 rquotad 100011 2 tcp 875 rquotad 100005 1 udp 47297 mountd 100005 1 tcp 52644 mountd 100005 2 udp 50758 mountd 100005 2 tcp 33739 mountd 100005 3 udp 50248 mountd 100005 3 tcp 36239 mountd 100003 2 tcp 2049 nfs 100003 3 tcp 2049 nfs 100003 4 tcp 2049 nfs 100227 2 tcp 2049 nfs_acl 100227 3 tcp 2049 nfs_acl 100003 2 udp 2049 nfs 100003 3 udp 2049 nfs 100003 4 udp 2049 nfs 100227 2 udp 2049 nfs_acl 100227 3 udp 2049 nfs_acl 100021 1 udp 40433 nlockmgr 100021 3 udp 40433 nlockmgr 100021 4 udp 40433 nlockmgr 100021 1 tcp 53532 nlockmgr 100021 3 tcp 53532 nlockmgr 100021 4 tcp 53532 nlockmgr 设置开机自启动：123456 ~]# chkconfig nfs on ~]# chkconfig rpcbind on ~]# chkconfig --list nfsnfs 0:off 1:off 2:on 3:on 4:on 5:on 6:off ~]# chkconfig --list rpcbindrpcbind 0:off 1:off 2:on 3:on 4:on 5:on 6:off 客户端启动RPC服务并设置开机自启动：12~]# /etc/init.d/rpcbind start~]# chkconfig rpcbind on 配置NFS的配置文件为/etc/exports设置共享目录/data1[root@nfsserver ~]# mkdir /data 编辑配置文件：123456789[root@nfsserver ~]# vim /etc/exports写入如下内容：#shared data for bbs by andy at 20151101/data 172.20.2.0/24(rw,sync)其中，/dat为要共享的目录，172.20.2.0/24为允许访问的网段（也可为*或可解析的主机名或域名），rw为读写权限，sync表示同步到磁盘重启NFS服务[root@nfsserver ~]# /etc/init.d/nfs reload 自检能否共享：123456789[root@nfsserver ~]# showmount -e localhostExport list for localhost:/data 172.20.2.0/24[root@nfsclient ~]# showmount -e 172.20.2.200（客户端地址）Export list for 172.20.2.200:/data 172.20.2.0/24若出现错误信息：`clnt_create: RPC: Port mapper failure - Unable to receive: errno 113 (No route to host)`关闭服务端与客户端iptables即可。 挂载：123456789101112[root@nfsclient ~]# mount -t nfs 172.20.2.200:/data /mnt[root@nfsclient ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/sda2 18G 2.5G 15G 15% /tmpfs 242M 84K 242M 1% /dev/shm/dev/sda1 283M 28M 240M 11% /boot172.20.2.200:/data 18G 2.6G 14G 16% /mnt配置开机挂载：[root@nfsclient ~]# vim /etc/rc.local添加如下信息：/bin/mount -t nfs 172.20.2.200:/data /mnt 测试：12[root@nfsclient mnt]# touch hello.txttouch: cannot touch `hello.txt': Permission denied 可以读，但是无法创建文件123456789[root@nfsserver ~]# ls -ld /datadrwxr-xr-x 2 root root 4096 Nov 1 19:08 /data[root@nfsserver ~]# chmod -R 777 /data[root@nfsclient mnt]# touch hello.txt[root@nfsclient mnt]# ll hello.txt -rw-r--r-- 1 nfsnobody nfsnobody 0 Nov 1 19:43 hello.txt 12345[root@nfsserver ~]# cat /var/lib/nfs/etab /data 172.20.2.0/24(rw,sync,wdelay,hide,nocrossmnt,secure,root_squash,no_all_squash,no_subtree_check,secure_locks,acl,anonuid=65534,anongid=65534,sec=sys,rw,root_squash,no_all_squash)[root@nfsserver ~]# grep 65534 /etc/passwdnfsnobody:x:65534:65534:Anonymous NFS User:/var/lib/nfs:/sbin/nologin 解决方案：12345[root@nfsserver ~]# chmod 755 /data[root@nfsserver ~]# chown -R nfsnobody.nfsnobody /data[root@nfsserver ~]# ls -ld /datadrwxr-xr-x 2 nfsnobody nfsnobody 4096 Nov 1 19:43 /data 注意：如果需要读写共享，一定要让本地目录可以被NFS客户端的用户（nfsnobody）进行读写操作。 NFS服务的相关功能组件12345678910111213141516[root@nfsserver ~]# ps -ef|grep -E "rpc|nfs"rpc 25375 1 0 18:40 ? 00:00:00 rpcbind --&gt;rpc服务root 25409 2 0 18:41 ? 00:00:00 [rpciod/0]root 25418 1 0 18:41 ? 00:00:00 rpc.rquotad --&gt;磁盘配额进程root 25423 1 0 18:41 ? 00:00:00 rpc.mountd --&gt;权限管理进程root 25430 2 0 18:41 ? 00:00:00 [nfsd4]root 25431 2 0 18:41 ? 00:00:00 [nfsd4_callbacks]root 25432 2 0 18:41 ? 00:00:00 [nfsd] --&gt;nfs主进程root 25433 2 0 18:41 ? 00:00:00 [nfsd]root 25434 2 0 18:41 ? 00:00:00 [nfsd]root 25435 2 0 18:41 ? 00:00:00 [nfsd]root 25436 2 0 18:41 ? 00:00:00 [nfsd]root 25437 2 0 18:41 ? 00:00:00 [nfsd]root 25438 2 0 18:41 ? 00:00:00 [nfsd]root 25439 2 0 18:41 ? 00:00:00 [nfsd]root 25466 1 0 18:41 ? 00:00:00 rpc.idmapd 以上的进程查看均可以执行man 进程名来查看进程的功能细节1[root@nfsserver ~]# man rpc.statd|... NFS配置文件权限参数简要说明 参数名称 参数用途 rw 表示可读可写权限 sync 请求或写入数据时，数据同步写入到NFS Server的硬盘后才会返回 all_squash 不管访问NFS Server共享目录的用户身份如何，它的权限都将被压缩成匿名用户，同时它的UID和GID都会变成nobody或nfsnobody账号身份；在多个NFS客户端同时读写NFS Server数据时，这个参数很有用 anonuid 参数以anon*开头即指anonymous匿名用户，这个用户的UID设置值通常为nobody或nfsnobody的UID值，当然此UID值也是可以自行设置的；但是UID必须存在于/etc/passwd中，在多NFS Clients时，如多台web server共享一个NFS目录时，通过此参数可以使得不同的NFS Clients写入的数据对所有NFS Clients保持同样的用户权限，亦即配置的匿名UID对应的用户权限 anongid 同anonuid，区别就是把UID换成GID 生产环境中配置NFS的重要技巧 确保所有服务器对NFS共享目录具有相同权限，可通过以下方式实现： 添加all_squash参数把所有客户端都压缩成匿名用户 通过anonuid与anongid指定的UID和GID用户 所有的客户端和服务端都需要有一个相同的UID和GID的用户，即nfsnobody（UID必须相同） NFS客户端mount挂载优化安全优化参数：1mount -t nfs -o nosuid,noexec,rw 172.20.2.190:/data /mnt 客户端性能优化参数：12[root@node2 mnt]# cat /proc/mounts |grep mnt172.20.2.190:/data/ /mnt nfs4 rw,nosuid,nodev,noexec,relatime,vers=4,rsize=65536,wsize=65536,namlen=255,hard,proto=tcp,port=0,timeo=600,retrans=2,sec=sys,clientaddr=172.20.2.195,minorversion=0,local_lock=none,addr=172.20.2.190 0 0 需要主要关注rsize与wsize两个参数；它们设定了NFS Server和NFS Client之间往来数据块的大小，它们的大小最好是1024的倍数，如果在客户端挂载时使用了这两个参数，可以让客户端读取和写入数据数据时一次性读写更多的数据包，因此可以提升访问性能和效率。另外还有noatime与nodiratime选项可以实现在读写磁盘时不更新文件和目录的时间戳（即不更新文件系统中文件对应的inode信息），这样就可以减少和磁盘系统的交互，提升磁盘读写效率。 挂载：1mount -t nfs -o nosuid,noexec,rsize=1024,wsize=1024,rw 172.20.2.190:/data /mnt 测试单个文件写入速度:12345678time dd if=/dev/zero of=/mnt/testfile bs=9k count=2000020000+0 records in20000+0 records out184320000 bytes (184 MB) copied, 24.3848 s, 7.6 MB/sreal 0m24.443suser 0m0.009ssys 0m3.918s 卸载并重新挂载：12umount -lf /mntmount -t nfs -o nosuid,noexec,rw 172.20.2.190:/data /mnt 测试单个文件写入速度:12345678time dd if=/dev/zero of=/mnt/testfile2 bs=9k count=2000020000+0 records in20000+0 records out184320000 bytes (184 MB) copied, 17.0386 s, 10.8 MB/sreal 0m17.093suser 0m0.005ssys 0m0.769s NFS网络文件系统优化挂载的参数建议Centos5.8 x86_64服务器端和客户端环境1mount -t nfs -o noatime,nodiratime,nosuid,noexec,soft,rsize=32768,wsize=32768,rw 172.20.2.190:/data /mnt Centos6.5 x86_64服务器端和客户端环境1mount -t nfs -o noatime,nodiratime,rsize=131072,wsize=131072 172.20.2.190:/data /mnt 强制卸载：1234[root@node2 mnt]# umount /mntumount.nfs: /mnt: device is busyumount.nfs: /mnt: device is busy[root@node2 mnt]# umount -lf /mnt 相关命令介绍showmount命令exportfs命令exportfs -rv等同于/etc/init.d/nfs reload加载配置生效 rpcinfo 命令rpcinfo -p [主机/localhost] NFS的状态信息查看NFS服务器配置的参数12~]# cat /var/lib/nfs/etab /data 172.20.2.0/24(rw,sync,wdelay,hide,nocrossmnt,secure,root_squash,no_all_squash,no_subtree_c heck,secure_locks,acl,anonuid=65534,anongid=65534,sec=sys,rw,root_squash,no_all_squash) NFS服务生产场景应用说明作用NFS服务可以让不同的客户端挂载使用同一目录，作为共享存储使用，这样可以保证不同节点客户端数据的一致性，在集群架构环境中经常会用到 NFS的优点 简单：容易上手，容易掌握，数据是在文件系统之上的 方便：部署快速，维护简单 可靠：从软件层面上看，数据可靠性高，经久耐用，数据是在文件系统之上的 稳定 NFS的局限 局限性是存在单点故障，如果NFS Server宕机了，则所有客户端都不能访问共享目录，可以通过负载均衡及高可用方案弥补 在高并发的场合，NFS效率或性能有限（一般几千万以下PV的网站不是瓶颈，除非网站架构太差） 客户端认证是基于ip和主机名的，权限根据ID识别，安全性一般（用于内网则问题不大） NFS数据是明文的，NFS对数据完整性不作验证 多台客户机器挂载NFS服务器时，连接管理维护麻烦。尤其NFS服务端出问题后，所有NFS客户端都挂掉状态（测试环境可使用autofs自动挂载解决） 生产应用场景大中小型网站（2000万PV以下）线上应用，都有用武之地。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ansible playbook使用示例]]></title>
      <url>%2F2016%2F03%2F02%2Fansible-playbook%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[示例1：编写playbook1234567891011121314[root@node11 ~]# cat nginx.yml - hosts: websrvs remote_user: root tasks: - name: create nginx group group: name=nginx system=yes gid=208 --&gt;模块名称 - name: create nginx user user: name=nginx system=yes uid=208 group=nginx --&gt;模块名称- hosts: dbsrvs remote_user: root tasks: - name: copy file to dbsrvs copy: src=/etc/inittab dest=/tmp/inittab.ans --&gt;模块名称 运行playbook1[root@node11 ~]# ansible-playbook nginx.yml 示例二123456[root@node11 ~]# mkdir conf[root@node11 ~]# cp /etc/httpd/conf/httpd.conf conf/[root@node11 ~]# vim conf/httpd.conf --&gt;将默认端口改为8080...Listen 8080... 123456789101112131415[root@node11 ~]# cat apache.yml - hosts: websrvs remote_user: root tasks: - name: install httpd package yum: name=httpd state=latest - name: install configuration file for httpd copy: src=/root/conf/httpd.conf dest=/etc/httpd/conf/httpd.conf notify: --&gt;若配置文件发生变化，就会触发下面的handlers触发器，执行相应操作 - restart httpd - name: start httpd service service: enabled=true name=httpd state=started handlers: - name: restart httpd service: name=httpd state=restarted 示例三12345678910111213141516171819[root@node11 ~]# vim apache.yml [root@node11 ~]# cat apache.yml - hosts: websrvs remote_user: root vars: --&gt;定义变量 - package_name: httpd - service_name: httpd tasks: - name: install httpd package yum: name=&#123;&#123; package_name &#125;&#125; state=latest --&gt;--&gt;引用变量package_name - name: install configuration file for httpd copy: src=/root/conf/httpd.conf dest=/etc/httpd/conf/httpd.conf notify: - restart httpd - name: start httpd service service: enabled=true name=&#123;&#123; service_name &#125;&#125; state=started --&gt;引用变量service_name handlers: - name: restart httpd service: name=httpd state=restarted 示例四1234567[root@node11 ~]# ansible 172.20.2.115 -m setup172.20.2.115 | success &gt;&gt; &#123; "ansible_facts": &#123; "ansible_all_ipv4_addresses": [ "172.20.2.115" ], ... 123456[root@node11 ~]# cat test.yml - hosts: websrvs remote_user: root tasks: - name: copy file copy: content="&#123;&#123; ansible_all_ipv4_addresses &#125;&#125;" dest=/tmp/vars.ans 12[root@node12 ~]# cat /tmp/vars.ans['172.20.2.115'] 示例五1234567[root@node11 ~]# cat /etc/ansible/hosts[websrvs]172.20.2.115 testvar="2.115"172.20.2.198 testvar="2.198"[dbsrvs]172.20.2.159 123456[root@node11 ~]# cat test.yml - hosts: websrvs remote_user: root tasks: - name: copy file copy: content="&#123;&#123; ansible_all_ipv4_addresses &#125;&#125;, &#123;&#123; testvar &#125;&#125;" dest=/tmp/vars.ans 12345[root@node12 ~]# cat /tmp/vars.ans['172.20.2.115'], 2.115[root@node13 ~]# cat /tmp/vars.ans['172.20.2.198'], 2.198 示例六1234[root@node11 ~]# cat /etc/ansible/hosts[websrvs]172.20.2.115 ansible_ssh_user=root ansible_ssh_pass=111111 --&gt;添加认证，这样即使没有进行ssh认证，也可以远程操作相应主机172.20.2.198 示例七（条件测试）123456789[root@node11 ~]# cat cond.yml - hosts: all remote_user: root vars: - username: user10 tasks: - name: create &#123;&#123; username &#125;&#125; user user: name=&#123;&#123; username &#125;&#125; when: ansible_hostname == "node12" --&gt;只有当条件满足时才执行相应操作 示例八（使用模板）123[root@node11 ~]# mkdir templates[root@node11 ~]# cp conf/httpd.conf templates/[root@node11 ~]# mv templates/httpd.conf templates/httpd.conf.j2 12345678[root@node11 ~]# cat templates/httpd.conf.j2...MaxClients &#123;&#123; maxClients &#125;&#125;...Listen &#123;&#123; http_port &#125;&#125;...ServerName &#123;&#123; ansible_fqdn &#125;&#125;... 1234[root@node11 ~]# cat /etc/ansible/hosts[websrvs]172.20.2.115 http_port=80 maxClients=100172.20.2.198 http_port=8080 maxClients=200 123456789101112131415161718[root@node11 ~]# cat apache.yml - hosts: websrvs remote_user: root vars: - package_name: httpd - service_name: httpd tasks: - name: install httpd package yum: name=&#123;&#123; package_name &#125;&#125; state=latest - name: install configuration file for httpd template: src=/root/templates/httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf notify: - restart httpd - name: start httpd service service: enabled=true name=&#123;&#123; service_name &#125;&#125; state=started handlers: - name: restart httpd service: name=httpd state=restarted 示例九（tags）tags表示在playbook中可以为某个或某些任务定义一个“标签”，在执行此playbook时，通过为ansible-playbook命令使用--tags选项来实现仅运行指定的tasks。1234567891011121314151617181920[root@node11 ~]# cat apache.yml - hosts: websrvs remote_user: root vars: - package_name: httpd - service_name: httpd tasks: - name: install httpd package yum: name=&#123;&#123; package_name &#125;&#125; state=latest - name: install configuration file for httpd template: src=/root/templates/httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf tags: --&gt;设置tag - conf notify: - restart httpd - name: start httpd service service: enabled=true name=&#123;&#123; service_name &#125;&#125; state=started handlers: - name: restart httpd service: name=httpd state=restarted 1234[root@node11 ~]# cat /etc/ansible/hosts[websrvs]172.20.2.115 http_port=80 maxClients=150172.20.2.198 http_port=8080 maxClients=180 1[root@node11 ~]# ansible-playbook apache.yml --tags="conf" --&gt;只运行tag为conf的playbook 示例十（roles）roles是ansible自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务模块及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。它一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程的场景中。 创建role的步骤如下 创建以roles命名的目录 在roles目录中分别创建以各角色名称命名的目录，如websrvs等 在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录；用不到的目录可以创建为空目录，也可以不创建 在palybook文件中调用各角色 roles内各目录中可用的文件tasks目录：至少应该包含一个名为main.yml的文件，其定义了此角色的任务列表；此文件可以使用include包含其它的位于此目录中的task文件files目录：存放由copy或script等模块调用的文件templates目录：template模块会自动在此目录中寻找Jinja2模板文件handlers目录：此目录中应当包含一个mainyml文件，用于定义此角色用到的各handler，在handler中使用include包含的其它的handler文件也应当位于此目录中vars目录：应当包含一个main.yml文件，用于定义此角色用到的变量meta目录：应当包含一个main.yml文件，用于定义此角色的特殊设定及其依赖关系；ansible1.3及其以后的版本才支持default目录：应当包含一个main.yml文件，用于为当前角色设定默认变量 123456789101112131415161718[root@node11 ~]# mkdir -pv ansible_playbooks/roles/&#123;websrvs,dbsrvs&#125;/&#123;tasks,files,templates,meta,handlers,vars&#125;[root@node11 ~]# tree ansible_playbooks/ansible_playbooks/└── roles ├── dbsrvs │ ├── files │ ├── handlers │ ├── meta │ ├── tasks │ ├── templates │ └── vars └── websrvs ├── files ├── handlers ├── meta ├── tasks ├── templates └── vars 12[root@node11 ansible_playbooks]# cd roles/websrvs/[root@node11 websrvs]# cp /etc/httpd/conf/httpd.conf files/ 1234567891011[root@node11 websrvs]# cat tasks/main.yml - name: install httpd package yum: name=httpd- name: install configuration file copy: src=httpd.conf dest=/etc/httpd/conf/httpd.cong tags: - conf notify: - restart httpd- name: start httpd service: name=httpd state=started 123[root@node11 websrvs]# cat handlers/main.yml- name: restart httpd service: name=httpd state=restarted 123[root@node11 websrvs]# yum -y install mysql-server[root@node11 websrvs]# cd ../dbsrvs/[root@node11 dbsrvs]# cp /etc/my.cnf files/ 12345678910111213[root@node11 dbsrvs]# cat tasks/main.yml - name: install mysql-server package yum: name=mysql-server state=latest- name: install configuration file copy: src=my.cnf dest=/etc/my.cnf tags: - myconf notify: - restart mysqld- name: start mysqld service: name=mysqld enabled=true state=started 123[root@node11 dbsrvs]# cat handlers/main.yml - name: restart mysqld service: name=mysqld state=restarted 12345678910111213141516[root@node11 ansible_playbooks]# cat site.yml - hosts: 172.20.2.115 remote_user: root roles: - websrvs- hosts: 172.20.2.198 remote_user: root roles: - dbsrvs- hosts: 172.20.2.159 remote_user: root roles: - websrvs - dbsrvs 1[root@node11 ansible_playbooks]# ansible-playbook site.yml 创建roles时需要注意以下几点 目录名同角色名 目录结构有固定格式 files：放置静态文件 templates：Jinjia2模板文件，可以使用相对路径直接调用 tasks：至少有一个main.yml文件，定义各tasks handlers：至少有一个main.yml文件，定义各handlers vars：至少有一个main.yml文件，定义变量 meta：定义依赖关系等信息 在site.yml中定义playbook]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ansible的安装以及常见模块的使用]]></title>
      <url>%2F2016%2F03%2F01%2Fansible%E7%9A%84%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[安装ansible(安装前要配置好epel源)1[root@node11 ~]# yum -y install ansible 查看安装完成后生成的文件12345[root@node11 ~]# rpm -ql ansible.../etc/ansible/ansible.cfg -&gt;主配置文件/etc/ansible/hosts -&gt;invertory文件，用于定义被管理主机... 编辑配置文件12345678[root@node11 ~]# vim /etc/ansible/hosts[websrvs]172.20.2.115 --&gt;node12172.20.2.198 --&gt;node13[dbsrvs]172.20.2.159 --&gt;node14 基于密钥方式认证1234[root@node11 ~]# ssh-keygen -t rsa[root@node11 ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub root@172.20.2.115[root@node11 ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub root@172.20.2.198[root@node11 ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub root@172.20.2.159 查看模块帮助12[root@node11 ~]# ansible-doc -l -&gt;查看有哪些模块[root@node11 ~]# ansible-doc -s MODULE_NAME -&gt;查看特定模块 ansible命令应用基础语法12345ansible &lt;host-pattern&gt; [-f forks] [-m module_name] [-a args]-f forks：启动的并发线程数-m module_name：要是用的模块-a args：模块特有的参数 常见模块command模块用于在远程执行命令，它是ansible的默认模块 示例1234567891011121314151617181920[root@node11 ~]# ansible 172.20.2.115 -a 'date'172.20.2.115 | success | rc=0 &gt;&gt;Mon Feb 29 23:14:45 PST 2016---[root@node11 ~]# ansible websrvs -a 'date'172.20.2.115 | success | rc=0 &gt;&gt;Mon Feb 29 23:15:43 PST 2016172.20.2.198 | success | rc=0 &gt;&gt;Mon Feb 29 23:16:11 PST 2016---[root@node11 ~]# ansible all -a 'date'172.20.2.159 | success | rc=0 &gt;&gt;Mon Feb 29 23:16:47 PST 2016172.20.2.198 | success | rc=0 &gt;&gt;Mon Feb 29 23:16:47 PST 2016172.20.2.115 | success | rc=0 &gt;&gt;Mon Feb 29 23:16:57 PST 2016 cron模块用于设置定时任务；state用于安装（present）或移除（absent）命令 示例123456789101112[root@node11 ~]# ansible websrvs -m cron -a 'minute="*/10" job="/bin/echo hello" name="test cron job"'[root@node11 ~]# ansible websrvs -a 'crontab -l'172.20.2.115 | success | rc=0 &gt;&gt;#Ansible: test cron job*/10 * * * * /bin/echo hello172.20.2.198 | success | rc=0 &gt;&gt;#Ansible: test cron job*/10 * * * * /bin/echo hello[root@node11 ~]# ansible websrvs -m cron -a 'name="test cron job" state=absent' --&gt;移除定时任务 user模块用于管理用户账户，用name指明创建的用户名 示例12[root@node11 ~]# ansible all -m user -a 'name="user1"' --&gt;在所有主机上创建user1用户[root@node11 ~]# ansible all -m user -a 'name="user1" state=absent' --&gt;删除用户 group模块用于实现组管理 示例12[root@node11 ~]# ansible websrvs -m group -a 'name=mysql gid=306 system=yes'[root@node11 ~]# ansible websrvs -m user -a 'name=mysql uid=306 system=yes group=mysql' copy模块用于实现文件复制;src指明本地源文件路径，dest指明远程目标文件路径，content可以取代src，表示直接用此处指定的信息生成为目标文件内容 示例12345678910[root@node11 ~]# ansible all -m copy -a 'src=/etc/fstab dest=/tmp/fstab.ansible owner=root mode=640'[root@node12 ~]# ll /tmp/fstab.ansible-rw-r----- 1 root root 805 Mar 1 00:11 /tmp/fstab.ansible---ansible all -m copy -a 'content="Hello Ansible\nHi FreeAndy" dest=/tmp/test.ansible'[root@node12 ~]# cat /tmp/test.ansibleHello AnsibleHi FreeAndy file模块用于设置文件属性；path指明文件路径，可以使用name或dest替代；创建文件链接可以使用src指定源文件，path指明符号链接文件路径 示例1234567[root@node11 ~]# ansible all -m file -a 'owner=mysql group=mysql mode=644 path=/tmp/fstab.ansible'[root@node12 ~]# ls -l /tmp-rw-r--r-- 1 mysql mysql 805 Mar 1 00:11 fstab.ansible---[root@node11 ~]# ansible all -m file -a 'path=/tmp/fstab.link src=/tmp/fstab.ansible state=link' --&gt;创建符号链接文件[root@node12 ~]# ls -l /tmplrwxrwxrwx 1 root root 18 Mar 1 00:28 fstab.link -&gt; /tmp/fstab.ansible ping模块用于测试远程主机是否能连通 示例1[root@node11 ~]# ansible all -m ping service模块指定运行状态；enabled设置是否开机自启动，取值为true或false；name指明服务名称；state指明状态，取值有started,stopped,restarted 示例12345678910111213[root@node11 ~]# ansible websrvs -a 'service httpd status'172.20.2.115 | FAILED | rc=3 &gt;&gt;httpd is stopped172.20.2.198 | FAILED | rc=3 &gt;&gt;httpd is stopped[root@node11 ~]# ansible websrvs -a 'chkconfig --list httpd'172.20.2.198 | success | rc=0 &gt;&gt;httpd 0:off 1:off 2:off 3:off 4:off 5:off 6:off172.20.2.115 | success | rc=0 &gt;&gt;httpd 0:off 1:off 2:off 3:off 4:off 5:off 6:off 123456789101112131415[root@node11 ~]# ansible websrvs -m service -a 'enabled=true name=httpd state=started'[root@node11 ~]# ansible websrvs -a 'service httpd status'172.20.2.115 | success | rc=0 &gt;&gt;httpd (pid 3621) is running...172.20.2.198 | success | rc=0 &gt;&gt;httpd (pid 3504) is running...[root@node11 ~]# ansible websrvs -a 'chkconfig --list httpd'172.20.2.115 | success | rc=0 &gt;&gt;httpd 0:off 1:off 2:on 3:on 4:on 5:on 6:off172.20.2.198 | success | rc=0 &gt;&gt;httpd 0:off 1:off 2:on 3:on 4:on 5:on 6:off shell模块用于在远程主机上运行命令，尤其是用到管道等功能的复杂命令时建议使用shell模块 示例123[root@node11 ~]# ansible all -m user -a 'name=user1'[root@node11 ~]# ansible all -m shell -a 'echo freeandy|passwd --stdin user1'[root@node11 ~]# ansible websrvs -m shell -a 'ss -tnl|grep 80' script模块用于将本地脚本复制到远程主机并运行，注意要使用相对路径指明脚本 示例123456[root@node11 ~]# cat test.sh #!/bin/bashecho "hello ansible from script" &gt; /tmp/script.ansibleuseradd user2[root@node11 ~]# ansible all -m script -a "test.sh" yum模块用于安装程序包；name指明要安装的程序包，可以带版本号，默认安装最新版本；state取值为present或latest表示安装，取值为absent表示卸载 示例1234567891011[root@node11 ~]# ansible all -m yum -a "name=zsh" --&gt;安装程序包[root@node11 ~]# ansible all -a 'rpm -q zsh' 172.20.2.115 | success | rc=0 &gt;&gt;zsh-4.3.11-4.el6.centos.1.x86_64172.20.2.198 | success | rc=0 &gt;&gt;zsh-4.3.11-4.el6.centos.1.x86_64172.20.2.159 | success | rc=0 &gt;&gt;zsh-4.3.11-4.el6.centos.1.x86_64 1234567891011[root@node11 ~]# ansible all -m yum -a "name=zsh state=absent" --&gt;卸载程序包[root@node11 ~]# ansible all -a 'rpm -q zsh'172.20.2.159 | FAILED | rc=1 &gt;&gt;package zsh is not installed172.20.2.198 | FAILED | rc=1 &gt;&gt;package zsh is not installed172.20.2.115 | FAILED | rc=1 &gt;&gt;package zsh is not installed setup模块用于收集远程主机的facts；每个被管理节点在接收并运行管理命令之前，会将自己主机的相关信息，如操作系统版本，IP地址等报告给远程的ansible主机 示例1[root@node11 ~]# ansible all -m setup]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL中的索引]]></title>
      <url>%2F2016%2F02%2F02%2FMySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%2F</url>
      <content type="text"><![CDATA[基本法则：索引应该构建在被用作查询条件的字段上。 索引类型B树索引使用B+树的数据结构来存储数据，它是顺序存储的，每个叶子节点到根节点的距离是相同的，查询过程是先全扫根节点然后找出二级分支节点然后是三级分支节点，最后找到叶子节点，而叶子节点有可能是指向最终数据所存放的数据块的指针，从而找到数据。B树索引是左前缀索引，因此它非常适合于查找范围类的数据。 可以使用B-Tree索引的查询类型主要有以下几个 全值匹配：精确查找某个值，例如”Jinjiao King” 匹配最左前缀：只精确匹配起头部分，例如”Jin%” 匹配范围值：查找某一范围内的字段 精确匹配某一列并范围匹配另一列：例如查找名字等于Jerry且年龄大于20岁的 只访问索引的查询：这次查询本身通过索引就能够直接找到最终结果而无需再去访问数据 不适合使用B-Tree索引的场景 如果查询不是从最左列开始，索引无效 不能跳过索引中的列 如果查询中某个列是范围查询，那么其右侧的列都无法再使用索引优化查询 Hash索引它是基于hash表来实现的，特别适用于精确匹配索引中的所有列；对MySQL来说，只有Memory存储引擎支持显式hash索引 适用场景 只支持等值比较查询，包括=,IN(),&lt;=&gt; 不适合使用hash索引的场景 存储的不是值的顺序，因此不适用于顺序查询 不支持匹配 空间索引在MySQL中只有MyISAM表支持空间索引，它可以存储地理位置数据，必须使用空间索引函数来调用 全文索引（FULLTEXT）在大段文本中查找关键词 索引的优点索引可以降低服务器需要扫描的数据量，减少了IO次数；索引可以帮助服务器避免排序和使用临时表；索引可以帮助将随机I/O转为顺序I/O 高性能索引策略 独立使用列，尽量避免其在布尔符号左侧参与运算； 左前缀索引：索引构建于字段的左侧的多少个字符，要通过索引选择性来评估；索引选择性指的是不重复的索引值与数据表的记录总数的比值； 多列索引：AND操作时更适合使用多列索引 选择合适的索引列次序：将选择性最高的放左侧 通过EXPLAIN来分析索引的有效性EXPLAIN能够获取查询执行计划信息，主要用来查询优化器如何执行查询。要使用EXPLAIN，只需要在查询中的SELECT关键字之前增加EXPLAIN就可以，MySQL会在查询上设置一个标记。当执行查询时，此标记会使其返回在执行计划中每一步的信息，而不是执行它。它会返回一行或多行信息，显示出执行计划中的每一部分和执行的次序。 执行EXPLAIN语句后，输出内容如下所示 MariaDB [hellodb]&gt; EXPLAIN SELECT Name FROM students WHERE StuID&gt;10\G; *************************** 1. row *************************** id: 1 select_type: SIMPLE table: students type: range possible_keys: PRIMARY key: PRIMARY key_len: 4 ref: NULL rows: 15 Extra: Using where id 表示当前查询语句中，每个SELECT语句的编号 select_type 表示查询类型，简单查询为SIMPLE；复杂查询有SUBQUERY（简单子查询），DERIVED（用于FROM中的子查询），UNION（UNION语句的第一个之后的SELECT语句），UNION RESULT（匿名临时表） table表示SELECT语句关联到的表 type表示关联类型或访问类型，即MySQL决定的如何去查找表中的行的方式； ALL表示全表扫描；index表示根据索引的次序进行的全表扫描； range表示有范围限制的根据索引实现范围扫描，扫描位置始于索引中的某一点，结束于另一点； ref表示根据索引返回表中匹配某单个值的所有行； eq_ref表示仅返回一个行，但需要额外与某个参考值作比较； const或system均表示直接返回单个行 possible_keys表示查询可能会用到的索引 key表示查询中使用了的索引 key_len表示在索引中使用的字节数 ref表示在利用key字段所表示的索引完成查询时所用的列或某常量值 rows表示MySQL估计为找到所有的目标行而需要读取的行数 Extra表示额外信息； “Using index”表示MySQL将会使用覆盖索引，以避免访问表； “Using where”表示MySQL服务器将在存储引擎检索后，再进行一次过滤； “Using temporary”表示MySQL对结果排序时会使用临时表； “Using filesort”表示MySQL将会对结果使用一个外部索引排序 type性能自上而下，性能越来越好，最起码应该将其保持在range上，若其为index或ALL则意味着全表扫描，性能会非常差，这时就需要改进索引或语句了。 MySQL中的索引就先介绍到这里，希望对大家有所帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL用户权限管理]]></title>
      <url>%2F2016%2F02%2F02%2FMySQL%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[MySQL中的权限类别MySQL中的权限按照对象级别可以划分为以下几个级别 库级别：用户是否有权限访问某一数据库 表级别：用户是否有权限对某一张表执行操作 字段级别：用户能否对某一字段发出查询或修改请求；MySQL的权限粒度支持到字段级别 管理类权限：能否创建其它用户并且允许其它用户获得的授权可以转让给其它第三方用户 程序类权限：是否有权限运行某个存储函数 管理类权限主要有以下几个权限CREATE TEMPORARY TABLES创建临时表CREATE USER创建用户FILE把当前数据库中的数据导出到一个文件系统上的文件当中SUPER特别高级别的一类权限SHOW DATABASES查看在已有权限下可以查询到的数据库RELOAD重新装载授权表SHUTDOWN是否拥有在MySQL数据库进程级别关闭数据库的权限REPLICATION SLAVE是否能够创建连接，以复制的方式连接至数据库服务器端REPLICATION CLIENT是否有权限去请求复制相关主服务器产生的事件LOCK TABLES请求在服务器级别对表施加锁操作PROCESS与进程相关的 程序类权限主要有以下几个权限{CREATE|ALTER|DROP|EXCUTE}FUNCTION{CREATE|ALTER|DROP|EXCUTE}PROCEDURE{CREATE|ALTER|DROP|EXCUTE}TRIGGER 库和表级别权限主要有以下几个权限ALTER修改数据库或表CREATE创建数据库或表CREATE VIEW是否有权限创建视图DROP删除数据库或表INDEX创建或删除索引SHOW VIEW查看视图GRANT OPTION能够把自己获得的权限赠给其它用户一个副本 字段级别相关权限主要有以下几个权限SELECT(col1,col2,...)INSERT(col1,col2,...)UPTATE(col1,col2,...) 若在授权时想要拥有所有权限，则使用ALL PRIVILEGES，可以简写为ALL 创建授予权限创建用户语法1CREATE USER 'USERNAME'@'HOST' [IDENTIFIED BY 'password'] --&gt;其中HOST主机名、IP地址（或网络地址）、通配符 查看用户获得的授权语法1SHOW GRANTS FOR 'USERNAME'@'HOST' 重命名用户语法1RENAME USER old_user_name TO new_user_name 删除用户语法1DROP USER 'USERNAME'@'HOST' 修改密码语法123SET PASSWORD FORUPDATE mysql.user SET password=PASSWORD('your_password') WHERE clause;--&gt;若想要设置生效，必须执行FLUSH PRIVILEGES命令mysqladmin password 忘记管理员密码的解决办法（离线操作）若忘记管理员登录密码，可以采用以下步骤重置密码 启动myslqd进程时，使用--skip-grant-tables,为了必变其他用户非法登入，建议使用--skip-networking禁止mysql远程登录 使用UPDATE命令修改管理员密码 关闭mysqld进程，移除--skip-grant-tables与--skip-networking两个选项，重启mysqld 1[root@mariadb ~]# vim /etc/init.d/mysqld 在start字段添加如下两项 12[root@mariadb ~]# service mysqld stop[root@mariadb ~]# service mysqld start 授权(GRANT)语法123456789101112131415161718192021222324252627282930313233343536373839404142434445GRANT priv_type [(column_list)] [, priv_type [(column_list)]] ... ON [object_type] priv_level TO user_specification [, user_specification] ... [REQUIRE &#123;NONE | ssl_option [[AND] ssl_option] ...&#125;] [WITH with_option ...]GRANT PROXY ON user_specification TO user_specification [, user_specification] ... [WITH GRANT OPTION]object_type: TABLE | FUNCTION | PROCEDUREpriv_level: * | *.* | db_name.* | db_name.tbl_name | tbl_name | db_name.routine_nameuser_specification: user [ IDENTIFIED BY [PASSWORD] 'password' | IDENTIFIED WITH auth_plugin [AS 'auth_string'] ]ssl_option: SSL | X509 | CIPHER 'cipher' | ISSUER 'issuer' | SUBJECT 'subject'with_option: GRANT OPTION | MAX_QUERIES_PER_HOUR count --&gt;每小时所允许执行的最大查询数 | MAX_UPDATES_PER_HOUR count --&gt;每小时所允许执行的最大更新数 | MAX_CONNECTIONS_PER_HOUR count --&gt;每小时所允许的最大连接数 | MAX_USER_CONNECTIONS count --&gt;同一个用户账号同时连接mysql的个数 例如1234CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'mypass';GRANT ALL ON db1.* TO 'jeffrey'@'localhost';GRANT SELECT ON db2.invoice TO 'jeffrey'@'localhost';GRANT USAGE ON *.* TO 'jeffrey'@'localhost' WITH MAX_QUERIES_PER_HOUR 90; 取消授权（REVOKE）语法1234567891011REVOKE priv_type [(column_list)] [, priv_type [(column_list)]] ... ON [object_type] priv_level FROM user [, user] ...REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] ...REVOKE PROXY ON user FROM user [, user] ... 例如1REVOKE INSERT ON *.* FROM 'jeffrey'@'localhost'; 取消用户所有授权则使用如下命令1REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] ... 关于权限的内容就先介绍到这里，在下一篇博文中将会为大家介绍索引相关的知识。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL中的事务简介]]></title>
      <url>%2F2016%2F02%2F01%2FMySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[概述及相关操作事务是一组原子性的SQL查询或者说是一个独立的工作单元；一个支持事务的引擎或关系型数据库必然是能够满足ACID测试的，所谓ACID测试指的是 A（原子性）：整个事务中的所有操作要么全部成功执行，要么全部失败后回滚 C（一致性）：数据库总是从一个一致性状态转换为另一个一致性状态 I（隔离性）：一个事务所做出的操作在提交之前，是不能为其它事务所见的；隔离有多种隔离级别 D（持久性）：一旦事务提交，其所做的修改会永久保存于数据库中 若要启动事务需要使用START TRANSACTION,结束事务有两种方式，一种是COMMIT（提交），一种是ROLLBACK（回滚）；只有事务型存储引擎才能支持此类操作。 1234[root@mariadb data]# wget http://7xq2gf.com1.z0.glb.clouddn.com/hellodb.sql --&gt;下载sql文件[root@mariadb data]# sed -i 's@ENGINE=MyISAM@ENGINE=InnoDB@ig' hellodb.sql --&gt;更改数据库引擎[root@mariadb data]# mysql &lt; hellodb.sql --&gt; 导入数据库 MariaDB [hellodb]&gt; SHOW TABLE STATUS\G; --&gt; 确保存储引擎为InnoDB 123456MariaDB [hellodb]&gt; SHOW GLOBAL VARIABLES LIKE '%autocommit%';+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit | ON |+---------------+-------+ 由查询结果可知，默认是启动了自动提交功能的，由于每一次提交都会因此磁盘IO操作，因此建议显式请求和提交事务，而不要使用“自动提交功能”1234567MariaDB [hellodb]&gt; SET SESSION autocommit=0; --&gt;关闭自动提交功能MariaDB [hellodb]&gt; SHOW VARIABLES LIKE '%autocommit%';+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit | OFF |+---------------+-------+ 1234567891011121314151617181920212223MariaDB [hellodb]&gt; START TRANSACTION; --&gt;启动事务MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID IN(18,23);+-------+----------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+----------+-----+--------+---------+-----------+| 18 | Hua Rong | 23 | M | 7 | NULL || 23 | Ma Chao | 23 | M | 4 | NULL |+-------+----------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; DELETE FROM students WHERE StuID IN(18,23);MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID IN(18,23);Empty set (0.00 sec)MariaDB [hellodb]&gt; ROLLBACK; --&gt;做回滚操作MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID IN(18,23); --&gt;数据尽然神奇地回来了+-------+----------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+----------+-----+--------+---------+-----------+| 18 | Hua Rong | 23 | M | 7 | NULL || 23 | Ma Chao | 23 | M | 4 | NULL |+-------+----------+-----+--------+---------+-----------+ 事务还支持savepoint(保存点),可以指定回滚操作只回到之前的某一个状态（以标识符标记），这跟在游戏中存档读档的概念是差不多的，朋友们可以认真领会。语法格式如下123SAVEPOINT identifierROLLBACK [WORK] TO [SAVEPOINT] identifierRELEASE SAVEPOINT identifier 例如1234567891011121314151617181920212223242526272829303132MariaDB [hellodb]&gt; START TRANSACTION;MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=18;+-------+----------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+----------+-----+--------+---------+-----------+| 18 | Hua Rong | 23 | M | 7 | NULL |+-------+----------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; DELETE FROM students WHERE StuID=18;MariaDB [hellodb]&gt; SAVEPOINT s1; --&gt;创建保存点，并将其标识为s1MariaDB [hellodb]&gt; INSERT INTO students (Name,Age,Gender) VALUEs('Jinjiao King',100,'M');MariaDB [hellodb]&gt; SAVEPOINT s2;MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=13;+-------+--------------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+--------------+-----+--------+---------+-----------+| 13 | Tian Boguang | 33 | M | 2 | NULL |+-------+--------------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; UPDATE students SET Age=43 WHERE StuID=13; MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID IN(18,13) OR Name='Jinjiao King';+-------+--------------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+--------------+-----+--------+---------+-----------+| 13 | Tian Boguang | 43 | M | 2 | NULL || 26 | Jinjiao King | 100 | M | NULL | NULL |+-------+--------------+-----+--------+---------+-----------+ 若此时发现修改的不正确，要回滚到修改数据之前，可以使用如下命令123456789MariaDB [hellodb]&gt; ROLLBACK TO s2;MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID IN(18,13) OR Name='Jinjiao King';+-------+--------------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+--------------+-----+--------+---------+-----------+| 13 | Tian Boguang | 33 | M | 2 | NULL || 26 | Jinjiao King | 100 | M | NULL | NULL |+-------+--------------+-----+--------+---------+-----------+ 事务隔离级别在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事物间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低；但是事务隔离级别越低其产生问题的可能性越大；一般而言主要存在以下问题 脏读：事务可以读取未提交的数据 不可重复读：一个事务从开始直到提交之前，所做的任何修改对其它事务都是不可见的 幻读：当某个事务在提取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行 加锁读：会在读取的每一行数据上都加锁 下面将使用两个会话来进行演示四个隔离级别，首先两个会话都需要关闭自动提交功能1234567891011121314MariaDB [hellodb]&gt; SHOW PROCESSLIST; --&gt;可以看到有两个会话+----+------+-----------+---------+---------+------+-------+------------------+----------+| Id | User | Host | db | Command | Time | State | Info | Progress |+----+------+-----------+---------+---------+------+-------+------------------+----------+| 8 | root | localhost | hellodb | Sleep | 1295 | | NULL | 0.000 || 9 | root | localhost | hellodb | Query | 0 | NULL | SHOW PROCESSLIST | 0.000 |+----+------+-----------+---------+---------+------+-------+------------------+----------+MariaDB [hellodb]&gt; SHOW GLOBAL VARIABLES LIKE '%isola%';+---------------+-----------------+| Variable_name | Value |+---------------+-----------------+| tx_isolation | REPEATABLE-READ |+---------------+-----------------+ tx_isolation是服务器变量，用来定义隔离级别，默认为REPEATABLE-READ，可在SESSION级进行修改 READ UNCOMMITTED（读未提交）在此级别事务中的修改，即使没有提交，对其它事务也都是可见的，会有脏读，不可重复读，幻读的问题；在实际应用中很少使用，演示过程如下 123456789101112131415161718192021222324252627282930313233343536MariaDB [hellodb]&gt; SET tx_isolation='READ-UNCOMMITTED'; --&gt;会话1 MariaDB [hellodb]&gt; START TRANSACTION; MariaDB [hellodb]&gt; SET tx_isolation='READ-UNCOMMITTED';--&gt;会话2MariaDB [hellodb]&gt; START TRANSACTION; MariaDB [hellodb]&gt; UPDATE students SET Age=40 WHERE StuID=13; --&gt;会话1 MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=13; +-------+--------------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+--------------+-----+--------+---------+-----------+| 13 | Tian Boguang | 40 | M | 2 | NULL |+-------+--------------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=13; --&gt;会话2; +-------+--------------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+--------------+-----+--------+---------+-----------+| 13 | Tian Boguang | 40 | M | 2 | NULL |+-------+--------------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; ROLLBACK; --&gt;会话1MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=13;+-------+--------------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+--------------+-----+--------+---------+-----------+| 13 | Tian Boguang | 33 | M | 2 | NULL |+-------+--------------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=13;--&gt;会话2;两次读到的数据不一样，即不可重复读+-------+--------------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+--------------+-----+--------+---------+-----------+| 13 | Tian Boguang | 33 | M | 2 | NULL |+-------+--------------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; ROLLBACK; --&gt; 会话2 READ COMMITED（读提交）这是大多数数据库系统默认的隔离级别（但MySQL不是）；一个事务从开始一直到提交之前所做的任何修改对其它事物都是不可见的。此级别存在不可重复读与幻读的问题。演示过程如下12345678910111213141516171819202122232425262728293031323334353637MariaDB [hellodb]&gt; SET tx_isolation='READ-COMMITTED'; --&gt;会话1MariaDB [hellodb]&gt; START TRANSACTION;MariaDB [hellodb]&gt; SET tx_isolation='READ-COMMITTED'; --&gt;会话2MariaDB [hellodb]&gt; START TRANSACTION; MariaDB [hellodb]&gt; INSERT INTO students (Name,Age,Gender) VALUEs('Jinjiao King',100,'M'); --&gt;会话1MariaDB [hellodb]&gt; SELECT * FROM students WHERE Name='Jinjiao King'; +-------+--------------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+--------------+-----+--------+---------+-----------+| 27 | Jinjiao King | 100 | M | NULL | NULL |+-------+--------------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; SELECT * FROM students WHERE Name='Jinjiao King'; --&gt;会话2，没有找到相应字段Empty set (0.00 sec)MariaDB [hellodb]&gt; DELETE FROM students WHERE StuID=1; --&gt;会话1MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=1; Empty set (0.00 sec)MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=1;--&gt;会话2+-------+-------------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+-------------+-----+--------+---------+-----------+| 1 | Shi Zhongyu | 22 | M | 2 | 3 |+-------+-------------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; COMMIT; --&gt;会话1MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=1; --&gt;会话2Empty set (0.00 sec)MariaDB [hellodb]&gt; SELECT * FROM students WHERE Name='Jinjiao King'; +-------+--------------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+--------------+-----+--------+---------+-----------+| 28 | Jinjiao King | 100 | M | NULL | NULL |+-------+--------------+-----+--------+---------+-----------+ REPEATABLE READ它是MySQL的默认事务隔离级别，该级别保证了在同一个事务中多次读取同样记录其结果是一致的，但是仍然会存在幻读的问题。演示过程如下1234567891011121314151617181920212223242526272829MariaDB [hellodb]&gt; SET tx_isolation='REPEATABLE-READ'; --&gt;会话1MariaDB [hellodb]&gt; START TRANSACTION; MariaDB [hellodb]&gt; SET tx_isolation='REPEATABLE-READ'; --&gt;会话2MariaDB [hellodb]&gt; START TRANSACTION; MariaDB [hellodb]&gt; DELETE FROM students WHERE StuID=3; --&gt;会话1MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=3;Empty set (0.00 sec)MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=3; --&gt;会话2+-------+-----------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+-----------+-----+--------+---------+-----------+| 3 | Xie Yanke | 53 | M | 2 | 16 |+-------+-----------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; COMMIT;--&gt;会话1MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=3; --&gt;会话2；数据依然存在，出现了幻读+-------+-----------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+-----------+-----+--------+---------+-----------+| 3 | Xie Yanke | 53 | M | 2 | 16 |+-------+-----------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; COMMIT; --&gt;会话2MariaDB [hellodb]&gt; SELECT * FROM students WHERE StuID=3;Empty set (0.00 sec) SERIALIZABLE它是最高的隔离级别。它通过强制事务串行执行，避免了脏读，不可重复读和幻读的问题，但是又导致了加锁读的新问题，这样就可能导致大量的超时和锁争用的问题；实际应用中很少用到此隔离级别，只有在非常需要确保数据的一致性而且可以接收没有并发的情况下，才考虑采用该级别。演示过程如下：123456789101112131415161718192021222324252627282930313233343536MariaDB [hellodb]&gt; SET tx_isolation='SERIALIZABLE'; --&gt;会话1MariaDB [hellodb]&gt; START TRANSACTION; MariaDB [hellodb]&gt; SET tx_isolation='SERIALIZABLE'; --&gt;会话2MariaDB [hellodb]&gt; START TRANSACTION; MariaDB [hellodb]&gt; SELECT * FROM students WHERE Name='Duan Yu';--&gt;会话1+-------+---------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+---------+-----+--------+---------+-----------+| 15 | Duan Yu | 19 | M | 4 | NULL |+-------+---------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; SELECT * FROM students WHERE Age&gt;22;+-------+---------------+-----+--------+---------+-----------+| StuID | Name | Age | Gender | ClassID | TeacherID |+-------+---------------+-----+--------+---------+-----------+| 4 | Ding Dian | 32 | M | 4 | 4 || 5 | Yu Yutong | 26 | M | 3 | 1 || 6 | Shi Qing | 46 | M | 5 | NULL || 11 | Yuan Chengzhi | 23 | M | 6 | NULL || 13 | Tian Boguang | 33 | M | 2 | NULL || 17 | Lin Chong | 25 | M | 4 | NULL || 18 | Hua Rong | 23 | M | 7 | NULL || 23 | Ma Chao | 23 | M | 4 | NULL || 24 | Xu Xian | 27 | M | NULL | NULL || 25 | Sun Dasheng | 100 | M | NULL | NULL || 28 | Jinjiao King | 100 | M | NULL | NULL |+-------+---------------+-----+--------+---------+-----------+MariaDB [hellodb]&gt; UPDATE students SET Age=25 WHERE StuID=15; --&gt;操作被阻塞ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionMariaDB [hellodb]&gt; COMMIT; --&gt;会话1MariaDB [hellodb]&gt; UPDATE students SET Age=25 WHERE StuID=15;--&gt;会话2Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 在mysql内部广泛存在着各式各样的锁操作，它们通过锁来解决资源竞争问题；但是有了锁以后难免会造成死锁的问题，所谓死锁指的是两个或多个事务在同一资源上相互征用，并请求锁定对方占用的资源的状态，死锁会导致出现非常慢的查询。为了避免死锁问题，数据库系统实现了各种死锁检测和死锁超时机制，例如InnoDB就能检测到死锁的循环依赖，并立即返回一个错误。 事务日志事务日志是保证数据持久以及回滚相当重要的一个工具。每一次事务提交时，此事务的所有修改操作不会立即写入到数据文件中而是先写事务日志，事务日志在磁盘上是一段连续的磁盘空间，它的写入类型为“追加”，因此其操作为“顺序IO”；它操作的是内存中的缓冲区而不是磁盘上的原文件，此日志通常也被称为“预写式日志”；万一数据库崩溃了，由于操作已经写入事务日志而不是数据文件中，这样在数据库重新启动时加载数据文件之后得到的只能是过期的数据，这就需要数据库在重启以后有一个崩溃后恢复的操作也就是将事务日志中的操作同步到数据文件中，崩溃后恢复的时间取决于事务日志的大小和其中所存储的事务日志的数量。事务日志一般是两个文件，第一个写满了然后写第二个并将第一个文件中的操作同步到数据文件中然后将第一个事务日志文件中的内容清空。1234[root@mariadb ~]# cd /mydata/data/[root@mariadb data]# ll-rw-rw----. 1 mysql mysql 5.0M Jan 28 18:04 ib_logfile0 --&gt;InnoDB事务日志文件，默认大小5M-rw-rw----. 1 mysql mysql 5.0M Dec 23 23:36 ib_logfile1 事务日志的大小以及存放位置等是可以自定义的12345678910MariaDB [(none)]&gt; SHOW GLOBAL VARIABLES LIKE '%innodb_log%';+---------------------------+---------+| Variable_name | Value |+---------------------------+---------+| innodb_log_block_size | 512 || innodb_log_buffer_size | 8388608 || innodb_log_file_size | 5242880 || innodb_log_files_in_group | 2 || innodb_log_group_home_dir | ./ |+---------------------------+---------+ 参数不支持运行时修改，需要修改配置文件重启服务才能生效；建议不要使用太大的事务日志，否则在崩溃恢复时就需要花费很长时间。 MySQL中事务的相关知识就先介绍到这里，希望朋友们可以有所收获；下一篇博文将会介绍MySQL中的用户权限管理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL中的存储引擎]]></title>
      <url>%2F2016%2F01%2F28%2FMySQL%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
      <content type="text"><![CDATA[MySql主流存储引擎InnoDBInnoDB既是目前Mysql默认的存储引擎也是Mysql默认的事务型存储引擎，它的设计目标是用来处理大量短期事务；它的数据是存储在“表空间（table spcae）”中。InnoDB存储引擎使用“表空间”的方式有以下两种 把所有InnoDB表的数据和索引放置在同一个“表空间”中；即便这些表属于不同的数据库也依然可以放置在同一个“表空间”中，此时表空间文件位于datadir定义的目录下，名称为ibdata1，ibdata2… 每个表单独使用一个“表空间”存储表的数据和索引，在mysql配置文件中设置innodb_file_per_table=ON即可实现此功能;此时数据文件（存储数据和索引）表现为table_name.ibd,而table_name.frm则为表格式定义文件；例如创建了一张名为t1的表，则其数据文件在datadir目录下的名称为t1.ibd InnoDB基于MVCC（多版本并发控制）机制来支持较高并支持所有的事务隔离级别，默认级别为“可重读”，并且通过间隙锁策略防止幻读的出现；更详细的内容可以参看我的下一篇博文。InnoDB表使用聚集索引，支持自适应哈希索引；支持行级锁，即一旦两个线程征用同一个资源时，就需要对数据进行加锁，而加锁的粒度就有行级锁与表级锁。 特性总结 数据存储：基于表空间实现 并发：通过MVCC以及间隙锁来实现 索引：聚集索引，额外可以使用辅助索引，所有的辅助索引都指向聚集索引 性能：通过预读操作、自适应哈希索引以及插入缓冲区等来提升其性能 备份：支持热备 MyISAMMyISAM支持全文索引，而InnoDB是不支持全文索引的；支持对表数据进行压缩；支持空间函数；不支持事务且为表级锁；不支持崩溃后安全恢复，若想要在mariadb中使用全文索引以及安全恢复机制可以采用MyISAM的升级版本Aria存储引擎 适用场景：只读（或者写较少）、表较小（可以接受长时间进行修复操作） 对于MyISAM来讲每一张表都有三个文件table_name.frm（表格式定义文件）,table_name.MYI（索引文件）,table_name.MYD（数据文件） 特性总结 加锁和并发：只支持表级锁 修复：需要手工或自动进行修复但有可能丢失数据 索引：非聚集索引 支持延迟更新索引键 支持压缩表：将表压缩以后进行存放 其它存储引擎CSV将普通的CSV格式文件（字段通过逗号分隔）作为MySQL表使用；此种表不支持索引，但是它可以在数据库运行过程当中可以copy文件也可以将EXCEL表存储为CSV格式以后导入到MySQL中，因此它可以在不同的数据库管理软件之间对数据进行导入导出操作 MRG_MYISAM将多个MyISAM表合并为一个虚拟表，在分表以后在实现整表数据查询时比较方便 BLACKHOLE没有实现任何存储机制，类似于/dev/null，如果将某张表定义为BLACKHOLE存储引擎，则往表中插入的所有数据都会悄悄丢弃，可以用于实现多级级联复制 MEMORY所有数据都保存于内存中，不需要磁盘IO，但是重启后数据会丢失，通常当做临时表使用；若需要快速访问数据且数据很少修改并且数据丢失对于业务没有影响的情况下可以使用；它也是唯一一个支持哈希索引的表，且其为表级锁。注意：MySQL为了避免临时表占用过多内存空间，定义了临时表最多能够使用多少内存，若超出此上限值则会将临时表存放在磁盘上，这样就会造成较慢的性能表现。 PERFORMANCE_SCHEMA伪存储引擎，其内部数据只有在MySQL启动起来以后才会存在，若MySQL关闭数据则会消失 ARCHIVE通常用于数据归档，仅支持SELECT和INSERT操作，不支持事务但支持行级锁和专用缓存区，若将来做数据仓库则可以选择MyISAM或ARCHIVE FEDERATED用于访问其它远程MySQL服务器的一个代理，它通过创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，而后完成数据存取 MariaDB支持的社区存储引擎还有很多，例如OQGraph，SphinxSE，ToKuaDB等，在这里就不作介绍了，有兴趣的朋友可以自行查询了解。 关于MySQL的存储引擎就先介绍到这里，希望朋友们能有所收获，下一篇博文我们将进一步了解MySQL中事务的相关知识，敬请期待！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL概述及SQL语句的使用]]></title>
      <url>%2F2016%2F01%2F27%2FMySQL%E6%A6%82%E8%BF%B0%E5%8F%8ASQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[概述数据库管理系统简称DBMS，它本身并不是数据库，它是一个可以实现大量数据管理的程序，这些大量的数据通常为某一个项目或方案所使用，这些供某些项目或方案使用的数据集合就称为数据库。因此Mysql或MariaDB本身只是一个程序而非数据库。 数据组织形式根据数据组织机制的不同，主要分为以下流派 层次模型所有数据组织是按照类似于文件系统自上而下组织的， 这种层次模型结构清晰但会牵一发而动全身，若要删除或修改一个节点就有可能影响整个分支。层次模型专用于为某个项目应用而设计所以它与应用程序的耦合度非常高导致后期维护很难，并且它也不支持实体之间定义关联关系，由此就产生了后来的网状模型。 网状模型网状模型中一个叶子节点可以有多个父节点，因此管理以及维护起来变得更加不方便。 关系模型简单来说，关系模型就是把所有数据都组织成由行与列组成的二维关系表。为了尽可能降低数据冗余度并增强数据维护时的便捷程度，它需要根据关系模型设计时的基本要求来设计表。 对象-关系模型对象-关系模型是对关系模型的一个扩展，它在关系模型下可以以对象模式存储数据 非关系模型像上面提到的层次与网状模型都是非关系型，因此它并不是一项新技术，只不过在大规模Web服务的今天又一次被推上了风口浪尖。关系型数据库中有一个非常重要的核心概念即事务以及它的设计范式；设计范式主要是为了降低冗余度以减少空间浪费，但由此势必会增加关系的复杂度，由此带来的结果就是我们有时为了查询一个人的信息就不得不在多张表中查询，而要通过多张表查询就要事先在表之间建立连接关系，这样就会消耗大量的内存和磁盘I/O使得其在面对大规模并发访问需求下变得压力非常大，性能非常差，因此人们就放弃了对冗余的要求，数据该重复存储就重复存储，反正现在空间很廉价，性能很宝贵，因此所谓的性能优化无非就是拿空间换时间，要不就是拿时间换空间。事务或范式的遵循是降低关系型模型性能的罪魁祸首，这也是催生在Web应用领域大规模采用非关系型数据库存储的重要原因。 编译安装mariadb创建逻辑卷作为数据存储目录[root@mariadb ~]# fdisk /dev/sdb [root@mariadb ~]# partx -a /dev/sdb [root@mariadb ~]# pvcreate /dev/sdb1 [root@mariadb ~]# vgcreate myvg /dev/sdb1 [root@mariadb ~]# lvcreate -L 10G -n mydata myvg [root@mariadb ~]# mke2fs -t ext4 /dev/myvg/mydata [root@mariadb ~]# mkdir -p /mydata/data [root@mariadb ~]# chown mysql.mysql /mydata/data 设置开机自动挂载[root@mariadb ~]# cat /etc/fstab ... /dev/myvg/mydata /mydata ext4 defaults 0 0 [root@mariadb ~]# mount -a [root@mariadb ~]# mount ... /dev/mapper/myvg-mydata on /mydata type ext4 (rw) 安装mariadb[root@mariadb ~]# mkdir tools [root@mariadb ~]# cd tools [root@mariadb tools]# wget http://7xoagk.com1.z0.glb.clouddn.com/mariadb-5.5.44.tar.gz 更新repo cd /etc/yum.repos.d/ mv CentOS-Base.repo CentOS-Base.repo.backup wget http://mirrors.163.com/.help/CentOS6-Base-163.repo yum clean all yum makecache yum -y groupinstall "Development Tools" "Platform Development Tools" yum -y install cmake groupadd -r -g 306 mysql useradd -r -g 306 -u 306 mysql yum -y install openssl-devel yum -y install ncurses-devel [root@mariadb tools]# tar xf mariadb-5.5.44.tar.gz [root@mariadb tools]# cd mariadb-5.5.44 [root@mariadb mariadb-5.5.44]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mariadb-5.5.44 -DMYSQL_DATADIR=/mydata/data -DSYSCONFDIR=/etc -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_ARCHIVE_STORAGE_ENGINE=1 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DWITH_SSL=system -DWITH_ZLIB=system -DWITH_LIBWRAP=0 -DMYSQL_UNIX_ADDR=/tmp/mysql.sock -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci [root@mariadb mariadb-5.5.44]# make &amp;&amp; make install [root@mariadb ~]# chown mysql.mysql /mydata/data/ [root@mariadb ~]# cd /usr/local/mariadb-5.5.44/ [root@mariadb mariadb-5.5.44]# chown -R root.mysql ./* [root@mariadb mariadb-5.5.44]# cd /usr/local/ [root@mariadb local]# ln -sv mariadb-5.5.44/ mysql [root@mariadb mysql]# scripts/mysql_install_db --user=mysql --datadir=/mydata/data [root@mariadb mysql]# mkdir /etc/mysql [root@mariadb mysql]# cp support-files/my-large.cnf /etc/mysql/my.cnf [root@mariadb mysql]# vim /etc/mysql/my.cnf 添加如下信息： datadir=/mydata/data innodb_file_per_table=ON skip_name_resolve=ON [root@mariadb mysql]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld [root@mariadb mysql]# chmod +x /etc/rc.d/init.d/mysqld [root@mariadb mysql]# chkconfig --add mysqld [root@mariadb mysql]# service mysqld start [root@mariadb mysql]# /usr/local/mysql/bin/mysql_secure_installation 添加环境变量12[root@mariadb mysql]# vim /etc/profile.d/mysql.shexport PATH=/usr/local/mysql/bin:$PATH 存储引擎Mysql5.1默认为MyISAM，同时提供InnoDB；Mysql5.5默认为InnoDB，同时提供MyISAM Mariadb存储引擎默认为InnoDB（实际上是Xtradb），同时提供Aria（MyISAM的增强版）关于存储引擎的内容，我会专门再写一篇博文进行介绍 SQL语句的组成 DDL（Data Defination Language ）,数据定义语言，如CREATE,DROP,ALTER DML （Data Manipulation Language）,数据操纵语言实现数据的CURD（增删查改），如INSERT,DELETE,SELECT,UPDATE 命令使用DDL存储引擎存储引擎也叫作表类型，也就是在创建每个表时都可以单独指明使用哪种存储引擎，但是在同一个库内的所有表应该使用同一类型。 MariaDB [mydb]&gt; SHOW ENGINES; --&gt;查看所有支持的存储引擎 查看表状态MariaDB [(none)]&gt; SHOW TABLE STATUS FROM mydb; MariaDB [mydb]&gt; SHOW TABLE STATUS\G --&gt;显示当前数据库内的所有表的状态信息（为了方便查看，使用了竖排显示） MariaDB [mydb]&gt; SHOW TABLE STATUS LIKE 'students'\G --&gt;查看students表状态 数据库管理操作1234567891011help CREATE DATABASE; --&gt;查看命令使用帮助SHOW CHARACTER SET; --&gt;查看当前mysql所支持的所有字符集SHOW COLLACTION; --&gt;显示mysql支持的所有排序规则CREATE DATABASE testdb; --&gt;创建数据库testdbCREATE DATABASE IF NOT EXISTS testdb; --&gt;加入限定条件，数据库不存在才创建,若数据库已存在，命令能够执行成功，但是会有警告信息SHOW WARNINGS; --&gt;查看警告信息SHOW DATABASES; --&gt;查看创建的数据库DROP DATABASE testdb; --&gt; 删除数据库（此举有风险，操作需谨慎）DROP DATABASE IF EXISTS testdb;加入限定条件，数据库存在才会删除CREATE DATABASE IF NOT EXISTS testdb CHARACTER SET 'utf8'; --&gt;以指定字符编码格式创建数据库SHOW CREATE DATABASE testdb; --&gt; 查看指定数据库以何种方式创建 表的管理操作创建表12345CREATE TABLE IF NOT EXISTS students (StuID INT UNSIGNED NOT NULL PRIMARY KEY,Name CHAR(30) NOT NULL,Age TINYINT UNSIGNED,Gender ENUM('M','F')); --&gt;创建students表DESC students; --&gt;查看students表结构SHOW TABLES; --&gt; 查看数据库中的表SHOW TABLES IN mysql; --&gt;查看指定数据库中的表（此处查看的是mysql数据库） 1234567891011121314CREATE TABLE mydb.teachers(Tid INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,Name VARCHAR(50) NOT NULL,Age TINYINT UNSIGNED,Gender ENUM('F','M') Default 'M',DaZhao VARCHAR(100),UNIQUE KEY(Name,Dazhao));MariaDB [(none)]&gt; DESC mydb.teachers;+--------+---------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------+---------------------+------+-----+---------+----------------+| Tid | int(10) unsigned | NO | PRI | NULL | auto_increment || Name | varchar(50) | NO | MUL | NULL | || Age | tinyint(3) unsigned | YES | | NULL | || Gender | enum('F','M') | YES | | M | || DaZhao | varchar(100) | YES | | NULL | |+--------+---------------------+------+-----+---------+----------------+MariaDB [(none)]&gt; SHOW INDEXES FROM mydb.teachers; --&gt;查看表上的索引 修改表123456789101112131415161718192021222324252627282930313233343536MariaDB [mydb]&gt; DESC students;+--------+---------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+---------------------+------+-----+---------+-------+| StuID | int(10) unsigned | NO | PRI | NULL | || Name | char(30) | NO | | NULL | || Age | tinyint(3) unsigned | YES | | NULL | || Gender | enum('M','F') | YES | | NULL | |+--------+---------------------+------+-----+---------+-------+MariaDB [mydb]&gt; ALTER TABLE students ADD ClassID SMALLINT UNSIGNED NOT NULL AFTER Name; --&gt;新增ClassID字段置于Name之后MariaDB [mydb]&gt; DESC students; +---------+----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+----------------------+------+-----+---------+-------+| StuID | int(10) unsigned | NO | PRI | NULL | || Name | char(30) | NO | | NULL | || ClassID | smallint(5) unsigned | NO | | NULL | || Age | tinyint(3) unsigned | YES | | NULL | || Gender | enum('M','F') | YES | | NULL | |+---------+----------------------+------+-----+---------+-------+MariaDB [mydb]&gt; ALTER TABLE students MODIFY ClassID TINYINT UNSIGNED NOT NULL AFTER Age;--&gt;修改ClassID类型为tinyint，并将其置于Age之后MariaDB [mydb]&gt; DESC students;+---------+---------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+---------------------+------+-----+---------+-------+| StuID | int(10) unsigned | NO | PRI | NULL | || Name | char(30) | NO | | NULL | || Age | tinyint(3) unsigned | YES | | NULL | || ClassID | tinyint(3) unsigned | NO | | NULL | || Gender | enum('M','F') | YES | | NULL | |+---------+---------------------+------+-----+---------+-------+ 删除表1DROP TABLE students; DMLINSERT123456789101112131415161718192021222324252627282930MariaDB [mydb]&gt; DESC teachers;+--------+---------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------+---------------------+------+-----+---------+----------------+| Tid | int(10) unsigned | NO | PRI | NULL | auto_increment || Name | varchar(50) | NO | MUL | NULL | || Age | tinyint(3) unsigned | YES | | NULL | || Gender | enum('F','M') | YES | | M | || DaZhao | varchar(100) | YES | | NULL | |+--------+---------------------+------+-----+---------+----------------+MariaDB [mydb]&gt; INSERT INTO teachers (Name,Age,Gender,Dazhao) VALUES ('Li Mochou','35','F','Bingpo');MariaDB [mydb]&gt; SELECT * FROM teachers;+-----+-----------+------+--------+--------+| Tid | Name | Age | Gender | DaZhao |+-----+-----------+------+--------+--------+| 1 | Li Mochou | 35 | F | Bingpo |+-----+-----------+------+--------+--------+MariaDB [mydb]&gt; INSERT INTO teachers (Name,Age,Gender,Dazhao) VALUES ('Hong Qi','80','M','Xianglong Shiba Zhang'),('Miejue Shitai','67','F','Hama Gong'); --&gt;一次插入多行MariaDB [mydb]&gt; SELECT * FROM teachers;+-----+---------------+------+--------+-----------------------+| Tid | Name | Age | Gender | DaZhao |+-----+---------------+------+--------+-----------------------+| 1 | Li Mochou | 35 | F | Bingpo || 2 | Hong Qi | 80 | M | Xianglong Shiba Zhang || 3 | Miejue Shitai | 67 | F | Hama Gong |+-----+---------------+------+--------+-----------------------+ DELETE12345678910111213141516MariaDB [mydb]&gt; DELETE FROM teachers WHERE Dazhao='Hama Gong';MariaDB [mydb]&gt; SELECT * FROM teachers;+-----+-----------+------+--------+-----------------------+| Tid | Name | Age | Gender | DaZhao |+-----+-----------+------+--------+-----------------------+| 1 | Li Mochou | 35 | F | Bingpo || 2 | Hong Qi | 80 | M | Xianglong Shiba Zhang |+-----+-----------+------+--------+-----------------------+MariaDB [mydb]&gt; DELETE FROM teachers LIMIT 1; --&gt; 限定只删除一行MariaDB [mydb]&gt; SELECT * FROM teachers;+-----+---------+------+--------+-----------------------+| Tid | Name | Age | Gender | DaZhao |+-----+---------+------+--------+-----------------------+| 2 | Hong Qi | 80 | M | Xianglong Shiba Zhang |+-----+---------+------+--------+-----------------------+ SELECT之单表查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182MariaDB [mydb]&gt; INSERT INTO teachers (Name,Age,Gender,Dazhao) VALUES ('Xiao Longnv','20','F','Yunv Xinjing'),('Miejue Shitai','67','F','Hama Gong');MariaDB [mydb]&gt; SELECT * FROM teachers;+-----+---------------+------+--------+-----------------------+| Tid | Name | Age | Gender | DaZhao |+-----+---------------+------+--------+-----------------------+| 2 | Hong Qi | 80 | M | Xianglong Shiba Zhang || 4 | Xiao Longnv | 20 | F | Yunv Xinjing || 5 | Miejue Shitai | 67 | F | Hama Gong |+-----+---------------+------+--------+-----------------------+MariaDB [mydb]&gt; SELECT Name FROM teachers WHERE Age&gt;30; --&gt; 显示年龄大于30的teacher名称+---------------+| Name |+---------------+| Hong Qi || Miejue Shitai |+---------------+MariaDB [mydb]&gt; SELECT * FROM teachers WHERE Gender='F' and Age&gt;50; --&gt;查找性别为女性，且年龄大于50的所有老师+-----+---------------+------+--------+-----------+| Tid | Name | Age | Gender | DaZhao |+-----+---------------+------+--------+-----------+| 5 | Miejue Shitai | 67 | F | Hama Gong |+-----+---------------+------+--------+-----------+MariaDB [mydb]&gt; SELECT * FROM teachers WHERE Age BETWEEN 30 AND 70;--&gt;查询年龄介于30与70之间的所有老师+-----+---------------+------+--------+-----------+| Tid | Name | Age | Gender | DaZhao |+-----+---------------+------+--------+-----------+| 5 | Miejue Shitai | 67 | F | Hama Gong |+-----+---------------+------+--------+-----------+MariaDB [mydb]&gt; SELECT * FROM teachers WHERE Name LIKE '%o%';--&gt; 查询名字中含有字符'o'的字段+-----+-------------+------+--------+-----------------------+| Tid | Name | Age | Gender | DaZhao |+-----+-------------+------+--------+-----------------------+| 2 | Hong Qi | 80 | M | Xianglong Shiba Zhang || 4 | Xiao Longnv | 20 | F | Yunv Xinjing |+-----+-------------+------+--------+-----------------------+MariaDB [mydb]&gt; SELECT * FROM teachers WHERE Name RLIKE '^[A-M].*i.*$';--&gt;查询Name中以字母A-M开头中间含有i字符的字段+-----+---------------+------+--------+-----------------------+| Tid | Name | Age | Gender | DaZhao |+-----+---------------+------+--------+-----------------------+| 2 | Hong Qi | 80 | M | Xianglong Shiba Zhang || 5 | Miejue Shitai | 67 | F | Hama Gong |+-----+---------------+------+--------+-----------------------+MariaDB [mydb]&gt; SELECT Gender FROM teachers;+--------+| Gender |+--------+| M || F || F |+--------+MariaDB [mydb]&gt; SELECT DISTINCT Gender FROM teachers;+--------+| Gender |+--------+| M || F |+--------+MariaDB [mydb]&gt; SELECT * FROM teachers ORDER BY Age; --&gt; 按年龄进行排序+-----+---------------+------+--------+-----------------------+| Tid | Name | Age | Gender | DaZhao |+-----+---------------+------+--------+-----------------------+| 4 | Xiao Longnv | 20 | F | Yunv Xinjing || 5 | Miejue Shitai | 67 | F | Hama Gong || 2 | Hong Qi | 80 | M | Xianglong Shiba Zhang |+-----+---------------+------+--------+-----------------------+MariaDB [mydb]&gt; SELECT * FROM teachers ORDER BY Age DESC; --&gt;按年龄降序排列+-----+---------------+------+--------+-----------------------+| Tid | Name | Age | Gender | DaZhao |+-----+---------------+------+--------+-----------------------+| 2 | Hong Qi | 80 | M | Xianglong Shiba Zhang || 5 | Miejue Shitai | 67 | F | Hama Gong || 4 | Xiao Longnv | 20 | F | Yunv Xinjing |+-----+---------------+------+--------+-----------------------+ UPDATE123456789MariaDB [mydb]&gt; UPDATE teachers SET Dazhao='Miejue Zhang' WHERE Tid=5;MariaDB [mydb]&gt; SELECT * FROM teachers;+-----+---------------+------+--------+-----------------------+| Tid | Name | Age | Gender | DaZhao |+-----+---------------+------+--------+-----------------------+| 2 | Hong Qi | 80 | M | Xianglong Shiba Zhang || 4 | Xiao Longnv | 20 | F | Yunv Xinjing || 5 | Miejue Shitai | 67 | F | Miejue Zhang |+-----+---------------+------+--------+-----------------------+ 用户及权限管理创建用户1MariaDB [mydb]&gt; CREATE USER 'wpuser'@'172.16.%.%' IDENTIFIED BY 'wppass'; --&gt; 创建用户wpuser，允许172.16.0.0网段访问，密码为wppass 删除用户1DROP USER 'username'@'host'; 用户授权1234567MariaDB [mydb]&gt; GRANT ALL ON mydb.* TO 'wpuser'@'172.16.%.%';--&gt; 授权wpuser用户访问mydb数据库的所有权限；如果用户实现不存在，则创建此账号并授权MariaDB [mydb]&gt; SHOW GRANTS FOR 'wpuser'@'172.16.%.%'; --&gt;查看用户已获得的授权MariaDB [mydb]&gt; REVOKE INSERT,UPDATE ON mydb.* FROM 'wpuser'@'172.16.%.%'; --&gt; 收回用户wpuser在数据库mydb中的INSERT与UPDATE权限 好了，SQL语句的相关知识就先介绍到这里，希望大家能够有所收获，下面一篇博文将详细介绍MariaDB存储引擎。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http反向代理之haproxy简要介绍]]></title>
      <url>%2F2016%2F01%2F14%2Fhttp%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8Bhaproxy%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[安装haproxycentos6.4以上的版本直接使用yum命令安装1[root@node11 ~]# yum -y install haproxy 查看生成的文件1234567[root@node11 ~]# rpm -ql haproxy.../etc/haproxy/haproxy.cfg --&gt; 配置文件/etc/rc.d/init.d/haproxy --&gt; 服务脚本/usr/sbin/haproxy #主程序... 提供测试页面12345[root@node12 ~]# cat /var/www/html/index.html&lt;h1&gt;Web1&lt;h1&gt;[root@node13 ~]# cat /var/www/html/index.html &lt;h1&gt;Web2&lt;/h1&gt; 简单实现编辑配置文件1[root@node11 haproxy]# cat haproxy.cfg 修改后，如下图所示1234[root@node11 haproxy]# service haproxy start[root@node11 haproxy]# ss -tnlp...LISTEN 0 128 *:80 *:* users:(("haproxy",3640,5)) 测试结果如下： 刷新页面 配置文件全局配置global配置中的参数为进程级别的参数，且通常与其运行的OS相关 进程管理及安全相关的参数 log &lt;address&gt; &lt;facility&gt; [max level [min level]]：定义全局的syslog服务器，最多可以定义2个 log-send-hostname [&lt;string&gt;]：在syslog信息的首部添加当前主机名，可以为“string”指定的名称，也可以缺省使用当前主机名 nbproc &lt;number&gt;：指定启动的haproxy进程的个数，只能用于守护进程模式的haproxy,默认只启动一个进程，鉴于调试困难等多方面的原因，一般只在单进程仅能打开少数文件描述符的场景中才使用多进程模式 性能调整相关参数 maxconn &lt;number&gt;：设定每个haproxy进程所接受的最大并发连接数 spread-checks &lt;0..50,in percent&gt;：在haproxy后端有着众多服务器的场景中，在精确的时间间隔后统一对众服务器进行健康状态检测可能会带来意外问题，此选项用于将其检查的时间间隔长度上增加或减小一定的随机时长 tune.maxpollevents &lt;number&gt;：设定一次系统调用可以处理的事件最大数，默认值取决于OS；其值小于200时可节约带宽，但会略微增大网络延迟，而大于200时可降低延迟，但会稍稍增加网络带宽的占用量 代理配置代理相关的配置可以在如下配置段中进行配置 defaults &lt;name&gt; frontend &lt;name&gt; backend &lt;name&gt; listen &lt;name&gt;“defaults”段用于为所有其它配置段提供默认参数“frontend”段用于定义一系列监听的套接字，这些套接字可接受客户端请求并与之建立连接“backend”段用于定义一系列“后端”服务器，代理会将对应客户端的请求转发至这些服务器“listen”段通过关联“前端”和“后端”定义了一个完整的代理，通常只对TCP流量有用 相关代理参数说明 balance 指明调度方法，算法可分为动态（权重可动态调整）和静态（调整权重不会实时生效）两种 default_backend &lt;backend&gt; 用于指明为请求提供服务的backend use_backend [{if|unless} &lt;condition&gt;] 条件式后端指定，其中是由ACL定义的 server &lt;name&gt; &lt;address&gt;[:[port][param *]] 其中用于内部标识；常用param有 check：启用对server的健康状态检测功能，默认情况下是对TCP层的监测。补充类参数inter指明每隔多长时间做一次监测，单位为毫秒，默认为2000；rise是某离线的server从离线状态转换至正常状态需要成功检查的次数；fall表示server从正常状态转换为不可用状态需要检查的次数，可以使用option httpchk指明健康状态检测的方案 cookie：分配给server的cookie信息，用于实现基于cookie调度用户请求将来自于同一个cookie的用户请求始终定向于同一个后端server disabled：设置服务器为禁用状态 maxconn：此服务器能接受的最大并发连接数 maxqueue：定义等待队列的最大长度，默认值为0，表示没有上限 weight：定义当前服务器的权重值 bind 此指令仅能用于frontend和listen区段，用于指明监听的地址和端口 mode {tcp|http|health} 指明haproxy的代理模式，默认为tcp模式 hash-type 定义将hash码映射至后端服务器的方法，有用方法有map-based和consistent option forwardfor [ except &lt;network&gt; ] [ header &lt;name&gt; ] [ if-none ] 允许在发往服务器的请求首部中插入“X-Forwarded-For”首部 调度方法roundrobin基于权重进行轮询，在服务器的处理时间保持均匀分布时，这时最平衡、最公平的算法；此算法是动态的，其权重可以在运行时进行调整，不过，在设计上，每个后端服务器仅能最多处理4128个连接 static-rr基于权重进行轮询，与roundrobin类似，但是为静态方法，在运行时调整其服务器权重不会生效，不过其在后端服务器连接数上没有限制 leastconn新的连接请求被派发至具有最少连接数目的后端服务器，在有着较长时间会话的场景中推荐使用此算法，如LDAP、SQL等，其并不太适用于较短会话的应用层协议，如HTTP；此算法是动态的，可以在运行时调整其权重 source将请求的源地址进行hash运算，并由后端服务器的权重总数相除后派发至某匹配的服务器，这样就使得同一个客户端IP的请求始终被派发至某特定的服务器；不过当服务器权重总数发生变化时，如某服务器宕机或添加了新的服务器，许多客户端的请求可能会被派发至与此前请求不同的服务器，常用于负载均衡无cookie功能的基于TCP的协议；其默认为静态，不过也可以使用hash-type修改此特性。如果hash-type为map-based（取模法）则为静态的，若其为consistent（一致性哈希），则为动态的。 uri对uri的左半部分（”问题标记之前的部分”）或整个uri进行hash运算，并由服务器的总权重相除后派发至某匹配的服务器；这样就使得对同一个uri的请求总是被派发至某特定的服务器，除非服务器的权重总数发生了变化；此算法常用于代理缓存或反病毒代理以提高缓存的命中率；需要注意的是，此算法仅应用于HTTP后端服务器场景；其默认为静态算法，不过也可以使用hash-type修改此特性，强烈建议将hash-type设置为consistent。 url_param通过为URL指定的参数在每个HTTP GET请求中将会被检索，如果找到了指定的参数且其通过等于号”=”被赋予了一个值，那么此值将被执行hash运算并被服务器总权重相除后派发至某匹配的服务器；此算法可以通过追踪请求中的用户标识进而确保同一个用户ID的请求将被送往同一个特定的服务器，除非服务器的总权重发生了变化；如果某请求中没有出现指定的参数或其没有有效值，则使用轮询算法对相应请求进行调度；此算法默认为静态的，不过其也可以使用hash-type修改此特性 hdr(name)对于每个HTTP请求，通过指定的HTTP首部将会被检索，如果相应的首部没有出现或其没有有效值，则使用轮询算法对相应请求进行调度；其有一个可选项”use_domain_only”，可在指定检索类似host类的首部时仅计算域名部分（比如通过www.freeandyblogs.com来说，仅计算freeandyblogs字符串的hash值）以降低hash算法的运算量；此算法默认为静态的，不过其也可以使用hash-type修改此特性。 启用状态页1[root@node11 haproxy]# cat haproxy.cfg 12345678910111213...backend appsrvs balance roundrobin server web1 172.20.2.225:80 check inter 6000 rise 1 fall 3 server web2 172.20.2.228:80 check inter 6000 rise 1 fall 3listen stats_page bind *:9001 stats enable --&gt;开启状态页 stats uri /haproxyadmin?stats --&gt;设置访问路径 stats auth admin:admin --&gt;设置访问权限 stats realm "My HAProxy Stats" --&gt; 设置弹出窗口提示文本 stats hide-version --&gt;隐藏haproxy版本信息 stats admin if TRUE --&gt;如果用户登录认证成功，则开启管理功能 具体效果如下图所示 对服务器进行更新时可以现将其设置为MAINT，等到更新完成后，再设置为READY]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac通过代理远程连接主机]]></title>
      <url>%2F2016%2F01%2F07%2FMac%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E4%B8%BB%E6%9C%BA%2F</url>
      <content type="text"><![CDATA[身为一名运维工程师，通过XSHELL等软件远程登录服务器进行操作已经成了家常便饭，当然在我的PC机上是装有XSHELL软件的，但是在苹果笔记本上就不知道怎样配置才能登录到代理服务器上，当时也在网上找了很多方法，但都没有成功，于是只能在移动硬盘上装了一台虚拟机；可是今天上班打开PC机，发现竟然不能上网了，移动硬盘又放在宿舍没有带来，还好我的MAC可以无线上网，于是就再次多方尝试使用笔记本连接到公司的服务器上，还好这一次总算是成功了，真可谓是一波三折啊，现在将我的配置过程分享出来，供各位朋友参考。 下载corkscrew12345wget http://www.agroman.net/corkscrew/corkscrew-2.0.tar.gztar xfz corkscrew-2.0.tar.gzcd corkscrew-2.0./configuremake &amp;&amp; make install 编辑~/.ssh/config文件1234567891011cat ~/.ssh/configHost app150 --&gt;别名，可以使用ssh app150进行登录HostName 192.168.0.150 --&gt;要登陆的服务器地址，可以有多个Port 22User zhijian.cao --&gt;用户名ServerAliveInterval 30 TCPKeepAlive yesControlPersist 4hIdentityFile ~/.ssh/caozhijian --&gt;这是我之前用XSHELL生成的私钥文件ProxyCommand /usr/local/bin/corkscrew IP PORT %h %p ~/.corkscrew-auth --&gt;IP与PORT分别为代理服务器地址与端口号，corkscrew-auth文件记录了代理服务器使用的用户名与密码，格式为username:password,例如zhijian.cao:111111 ssh服务器为了安全考虑发现客户端长时间闲置的话会主动断开ssh连接，如果不想ssh自动断开，ssh客户端需要打开TCPKeepAlive选项定时给服务器发TCP包来欺骗服务器，让ssh服务器感觉客户端还在“活动”中。同时ssh服务器端也需要打开TCPKeepAlive选项12cat /etc/ssh/sshd_config|grep TCPKeepAliveTCPKeepAlive yes 到这里就已经配置完成了，可以使用ssh命令远程登录服务器愉快地玩耍了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[集群服务之lvs-dr类型的实现]]></title>
      <url>%2F2016%2F01%2F06%2F%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E4%B9%8Blvs-dr%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[实验拓扑图实验拓扑如下图所示 要点 各RS要直接响应Client，因此各RS均需配置VIP；但仅能够让Director上的VIP能够与本地路由进行通信； Director不会拆除或修改请求报文的IP首部，而是通过封装新的帧首部（源MAC为Director的MAC地址，目标MAC为挑选出的RS的MAC地址）完成调度 为了保证RS上的VIP不会对ARP广播报文进行响应可以有三种实现方式 在前端路由器上静态指定 通过arptables 通过修改内核参数来限制arp通告和响应级别 修改内核参数： arp_ignore：定义接收到ARP请求时的响应级别 0：只要本地配置有响应地址，就给与响应 1：仅在请求的目标地址配置请i去到达的接口上的时候，才进行响应 arp_announce：定义主机将自己的地址想外通告时的通告级别 0：将本地任何接口上的任何地址向外通告 1：向目标网络通告与其网络匹配的地址 2：仅向本地接口上匹配的网络进行通告 这里采用第三种方式,有关arp的相关内容可参考本文末尾给出的链接 配置过程修改内核参数node12 [root@node12 ~]# echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore [root@node12 ~]# echo 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore [root@node12 ~]# echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce [root@node12 ~]# echo 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce node13 [root@node13 ~]# echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore [root@node13 ~]# echo 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore [root@node13 ~]# echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce [root@node13 ~]# echo 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce 设置VIPnode11 [root@node11 ~]# ifconfig eth0:0 172.20.2.145 netmask 255.255.255.255 broadcast 172.20.2.145 up node12 [root@node12 ~]# ifconfig lo:0 172.20.2.145 netmask 255.255.255.255 broadcast 172.20.2.145 up node13 [root@node13 ~]# ifconfig lo:0 172.20.2.145 netmask 255.255.255.255 broadcast 172.20.2.145 up 定义集群服务node12 [root@node12 ~]# route add -host 172.20.2.145 dev lo:0 node13 [root@node13 ~]# route add -host 172.20.2.145 dev lo:0 node11 [root@node11 ~]# route add -host 172.20.2.145 dev eth0:0 [root@node11 ~]# sysctl -a|grep ip_forward net.ipv4.ip_forward = 1 [root@node11 ~]# ipvsadm -C [root@node11 ~]# iptables -F [root@node11 ~]# ipvsadm -A -t 172.20.2.145:80 -s rr [root@node11 ~]# ipvsadm -a -t 172.20.2.145:80 -r 172.20.2.115 -g -w 1 [root@node11 ~]# ipvsadm -a -t 172.20.2.145:80 -r 172.20.2.104 -g -w 3 测试通过物理机访问VIP地址，效果如下图所示 刷新以后 配置过程总结对于Director而言 VIP配置在物理接口的别名上ifconfig INTERFACE:ALIAS $vip netmask 255.255.255.255 broadcast $vip 配置路由信息route add -host $vip dev INTERFACE:ALIAS 对于各RS而言 先修改内核参数echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore echo 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce echo 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce VIP配置在lo的别名上ifconfig lo:0 $vip netmask 255.255.255.255 broadcast $vip 配置路由信息route add -host $vip dev lo:0 关于arp_announce与arp_ignore]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[集群服务之lvs-nat类型的实现]]></title>
      <url>%2F2016%2F01%2F05%2F%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E4%B9%8Blvs-nat%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[lvs-nat原理图 lvs-nat实验拓扑如上图所示，node11作为Director，node12与node13为两台RS 配置步骤为node11添加一块网卡并将其类型设置为Vmnet2，这时会有两个网络接口，一个为桥接模式，一个为VMnet2；将node12与node13的网络连接方式设置为Vmnet2node111[root@node11 ~]# ifconfig eth1 192.168.10.11/24 up node121[root@node12 ~]# ifconfig eth0 192.168.10.12/24 up 编辑测试页面123[root@node12 ~]# cat /var/www/html/index.html &lt;h1&gt;node12&lt;h1&gt;[root@node12 ~]# service httpd start 设置路由12345678910[root@node12 ~]# route add default gw 192.168.10.11[root@node12 ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.10.0 0.0.0.0 255.255.255.0 U 1 0 0 eth00.0.0.0 192.168.10.11 0.0.0.0 UG 0 0 0 eth0[root@node12 ~]# ping 172.20.2.175 --&gt;确保能ping通PING 172.20.2.175 (172.20.2.175) 56(84) bytes of data.64 bytes from 172.20.2.175: icmp_seq=1 ttl=64 time=0.956 ms node131[root@node13 ~]# ifconfig eth0 192.168.10.13/24 up 编辑测试页面123[root@node13 ~]# cat /var/www/html/index.html&lt;h1&gt;node13&lt;/h1&gt;[root@node13 ~]# service httpd start 设置路由12345678910[root@node13 ~]# route add default gw 192.168.10.11[root@node13 ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.10.0 0.0.0.0 255.255.255.0 U 1 0 0 eth00.0.0.0 192.168.10.11 0.0.0.0 UG 0 0 0 eth0[root@node13 ~]# ping 172.20.2.175 --&gt;确保能ping通PING 172.20.2.175 (172.20.2.175) 56(84) bytes of data.64 bytes from 172.20.2.175: icmp_seq=1 ttl=64 time=1.39 ms node11测试页面能否正常访问1234[root@node11 ~]# curl http://192.168.10.12&lt;h1&gt;node12&lt;h1&gt;[root@node11 ~]# curl http://192.168.10.13&lt;h1&gt;node13&lt;/h1&gt; 配置ipvs规则,在配置ipvs之前确保iptables规则为空1234567891011[root@node11 ~]# ipvsadm -A -t 172.20.2.175:80 -s rr[root@node11 ~]# ipvsadm -a -t 172.20.2.175:80 -r 192.168.10.12 -m -w 1[root@node11 ~]# ipvsadm -a -t 172.20.2.175:80 -r 192.168.10.13 -m -w 3[root@node11 ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 172.20.2.175:80 rr -&gt; 192.168.10.12:80 Masq 1 0 0 -&gt; 192.168.10.13:80 Masq 3 0 0 开启核心转发功能123456789[root@node11 ~]# cat /proc/sys/net/ipv4/ip_forward 0[root@node11 ~]# cat /etc/sysctl.conf --&gt;将net.ipv4.ip_forward的值设置为1...net.ipv4.ip_forward = 1...[root@node11 ~]# sysctl -p --&gt;让配置立即生效 测试在浏览器中输入VIP地址，即172.20.2.175，出现如下页面 刷新页面 查看一下统计结果1[root@node11 ~]# ipvsadm -L -n --stats 由图所示，结果接近1:1 修改调度算法，再次进行测试123[root@node11 ~]# ipvsadm -E -t 172.20.2.175:80 -s wrr[root@node11 ~]# ab -n 10000 -c 100 http://172.20.2.175/index.html --&gt;为了效果更明显，可以多运行几次[root@node11 ~]# ipvsadm -L -n --stats 测试结果接近1:3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ipvsadm命令的用法]]></title>
      <url>%2F2016%2F01%2F05%2Fipvsadm%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[查看内核在编译时是否支持ipvs1[root@node11 ~]# grep -i 'ipvs' -A 5 /boot/config-2.6.32-504.el6.x86_64 安装ipvsadm12[root@node11 ~]# yum -y install ipvsadm[root@node11 ~]# rpm -ql ipvsadm 管理集群服务添加或修改命令格式123456ipvsadm -A|E -t|u|f service-address [-s scheduler] -A 添加 -E 修改 -t 承载的应用层协议是基于tcp协议提供服务的协议；其service-address的格式为"VIP：PORT"，如172.20.2.175:80-u 承载的应用层协议是基于udp协议提供服务的协议；其service-address的格式为"VIP：PORT"，如172.20.2.175:53-f 承载的应用层协议是基于tcp或udp协议提供服务的协议，但此类报文会经由iptables/netfilter打标记，即为防火墙标记；其service-address的格式为"FWM"，如"10"-s 指明调度方法，默认为wlc 示例1234567[root@node11 ~]# ipvsadm -A -t 172.20.2.175:80[root@node11 ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 172.20.2.175:80 wlc 删除命令格式1ipvsadm -D -t|u|f service-address 示例123456[root@node11 ~]# ipvsadm -D -t 172.20.2.175:80[root@node11 ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn 管理集群服务的RS添加或修改命令格式123456789ipvsadm -a|e -t|u|f service-address -r server-address [-g|i|m] [-w weight]-r server-address 指明RS，其server-address的格式一般为"IP[:PORT]",只有支持端口映射的lvs类型中才应该显式指定此处端口[-g|i|m] 指明lvs类型；默认为dr类型 -g即gateway，意为dr类型 -i即ipip，意为tun类型 -m即masquerade，意为nat类型[-w weight] 当前RS的权重，仅对于支持加权调度的scheduler权重才有意义 示例12345678910111213141516171819[root@node11 ~]# ipvsadm -A -t 172.20.2.175:80[root@node11 ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 172.20.2.175:80 wlc[root@node11 ~]# ipvsadm -a -t 172.20.2.175:80 -r 192.168.10.7 -m -w 2[root@node11 ~]# ipvsadm -a -t 172.20.2.175:80 -r 192.168.10.8 -m -w 5[root@node11 ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 172.20.2.175:80 wlc -&gt; 192.168.10.7:80 Masq 2 0 0 -&gt; 192.168.10.8:80 Masq 5 0 0 删除命令格式1ipvsadm -d -t|u|f service-address -r server-address 示例12345678[root@node11 ~]# ipvsadm -d -t 172.20.2.175:80 -r 192.168.10.7[root@node11 ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 172.20.2.175:80 wlc -&gt; 192.168.10.8:80 Masq 5 0 0 清空所有集群服务的定义123456[root@node11 ~]# ipvsadm -C[root@node11 ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn 保存及恢复集群服务或RS的定义三种方式1234567ipvsadm -S &gt; /etc/sysconfig/ipvsadm ipvsadm-save &gt; /etc/sysconfig/ipvsadm service ipvsadm saveipvsadm -R &lt; /etc/sysconfig/ipvsadmipvsadm-restore &lt; /etc/sysconfig/ipvsadmservice ipvsadm restart 示例123456789101112131415161718192021222324[root@node11 ~]# ipvsadm -A -t 172.20.2.175:80 -s wrr[root@node11 ~]# ipvsadm -a -t 172.20.2.175:80 -r 192.168.10.7 -w 2[root@node11 ~]# ipvsadm -a -t 172.20.2.175:80 -r 192.168.10.8 -w 5[root@node11 ~]# service ipvsadm save[root@node11 ~]# cat /etc/sysconfig/ipvsadm-A -t 172.20.2.175:80 -s wrr-a -t 172.20.2.175:80 -r 192.168.10.7:80 -g -w 2-a -t 172.20.2.175:80 -r 192.168.10.8:80 -g -w 5[root@node11 ~]# ipvsadm -C[root@node11 ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn[root@node11 ~]# ipvsadm -R &lt; /etc/sysconfig/ipvsadm[root@node11 ~]# ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 172.20.2.175:80 wrr -&gt; 192.168.10.7:80 Route 2 0 0 -&gt; 192.168.10.8:80 Route 5 0 0 查看规则命令格式1234567ipvsadm -L|l [options]options -c 列出当前所有connection --stats 列出统计数据 --rate 列出速率 -n或--number 数字格式显示IP及端口 --exact 列出精确值 清空计数器命令格式1ipvsadm -Z [-t|u|f service-address]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入浅出负载均衡集群lvs]]></title>
      <url>%2F2016%2F01%2F04%2Flvs%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[当服务器遇到性能瓶颈需要进行扩展时，一般来说会有两种解决思路：Scale up和Scale out，亦即水平扩展与垂直扩展 垂直扩展通常指增加CPU和内存，需要购买昂贵的高性能服务器 优点 耗电量相比使用多台服务器要少 实施简单 缺点 价格昂贵 有很大的硬件故障导致服务不可用的风险 由于资源的争用，服务器性能的增长会越来越小 受限于供应商，并且可扩展升级的空间是有限的 水平扩展通常指增加多台普通配置的服务器 优点 比起垂直扩展更加经济实惠 有容错能力 有很大扩展空间 易升级 缺点 服务器的维护与管理更加麻烦 耗电与制冷的费用比垂直扩展高 若使用付费授权软件，那么就会增加lisence的费用一般来说，随着服务器性能的提升，其价格也是指数级上升的，使用水平扩展的方式能够节约很多成本，同事还能整个服务器的容错能力 负载均衡集群负载均衡集群指的是使用多台提供相同服务的服务器组成集群系统，提高服务器的并发处理能力。负载均衡服务器的前端使用一个调度器，将客户端请求平均分配到后端的服务器中，同时调度器可能还具有后端服务器状态检测的的功能，将出现故障的服务器自动下线，使得集群具有一定的容错能力 使用负载均衡集群能够有效地扩展服务的并发能力，负载均衡集群中的主机应该尽量低耦合，最好是无状态的，这样就能够方便的增加主机实现扩展 常见的负载均衡器根据工作在的协议层可划分为： 四层负载均衡：根据请求报文中的目标地址和端口进行调度 七层负载均衡：根据请求报文的内容进行调度，此种调度属于代理的方式 根据软硬件划分： 硬件负载均衡： F5的BIG-IP Citrix的NetScaler 这类硬件负载均衡器通常能同时提供四层和七层负载均衡，但同时价格不菲 软件负载均衡： TCP层：LVS，Haproxy，Nginx 基于http协议：Haproxy，squid,varnish 基于MySQL协议：mysql-proxy LVSLVS是工作在四层的负载均衡器，它的实现和iptables/netfiler类似，工作在内核空间的TCP/IP协议栈上，LVS工作在INPUT Hook Function上，并在INPUT设置附加规则，一旦客户端请求的是集群服务，LVS会强行修改请求报文，将报文发往POSTROUTING，转发至后端的主机 LVS的设备地址命名 客户端IP：CIP 调度器中面向客户端的IP叫做VIP 调度器直接与后端服务器通信的IP叫做DIP 后端提供服务的主机地址叫做RIP 后端提供服务的主机即Real Server简称RS LVS的类型lvs-nat LVS-NAT类似于DNAT，但支持多目标转发，当客户端请求的是集群服务时，LVS修改请求报文的目标地址为RIP，转发至后端的RS，并修改后端响应报文的源地址为VIP，响应至客户端 在LVS-NAT类型下，Director进出请求报文都经过Director，因此Director的压力比较大 架构特性 集群节点与Director必须在同一个IP网络中 RIP通常是私有地址，仅用于各集群节点间的通信 Director位于client与Realserver之间负责处理进出的所有报文 Realserver必须将网关指向DIP 支持端口影视 较大规模场景中，Director易成为系统瓶颈 lvs-drDR值Direct Routing，直接路由，DR模型中，Director 和Realserver 处在同一网络中，对于Director，VIP用于接受客户端请求，DIP用于和Realserver通信。对于Realserver，每个Realserver都配有和Director相同的VIP（此VIP隐藏，关闭对ARP请求的响应），仅用户响应客户端的请求，RIP用于和Director通信。 当客户端请求集群服务时，请求报文发送至Director的VIP（Realserver的 VIP不会响应ARP请求），Director将客户端报文的源和目标MAC地址进行重新封装，将报文转发至Realserver，Realserver接收转发的报文。此时报文的源IP和目标IP都没有被修改，因此Realserver接受到的请求报文的目标IP地址为本机配置的VIP，它将使用自己的VIP直接响应客户端。 LVS-DR模型中，客户端的响应报文不会经过Director，因此Director的并发能力有很大提升。 架构特性 保证前端路由器将将目标地址为VIP的请求报文通过ARP地址解析后送往Director 静态绑定：在前端路由直接将VIP对应的目标MAC静态配置为Director的MAC地址 arptables：在各RS上，通过arptables规则拒绝其响应对VIP的ARP广播请求 修改内核参数：在各RS上修改内核参数并结合地址的配置方式实现拒绝响应对VIP的ARP广播请求 RS的RIP可以使用私有地址；但也可以使用公网地址，此时可通过互联网上的主机直接对此RS发起管理操作 Director仅负责处理入站请求，响应报文由RealServer直接发往客户端 各RIP与DIP必须在同一个物理网络中 Realserver不能将网关指向DIP，而直接使用前端网关 不支持端口映射 LVS-TUN和DR模型类似，Realserver都配有不可见的VIP，Realserver的RIP是公网地址，且可能和DIP 不再同一网络中。当请求到达 Director 后，Director不修改请求报文的源IP和目标IP 地址，而是使用IP隧道技术，使用DIP作为源IP，RIP作为目标IP再次封装此请求报文，转发至 RIP的Realserver上，Realserver解析报文后仍然使用VIP作为源地址响应客户端。 架构特性 RIP，DIP，VIP都是公网地址 RS的网关不能也不可能指向DIP 请求报文由Director分发，但响应报文直接由RS响应给客户端 Realserver使用自己的网关而不是Director RS的操作系统必须得支持IP隧道 不支持端口映射 lvs-fullnat类似于DNAT，它通过修改请求报文的源地址为DIP，目标地址为RIP来实现转发；对于响应报文而言，修改源地址为VIP，目标地址为CIP来实现转发 架构特性 RIP，DIP可以使用私有地址 RIP和DIP可以不在同一个网络中，且RIP的网关未必需要指向DIP 支持端口映射 RS的OS可以使用任意类型 请求报文和响应报文均经由Director LVS的调度方法当LVS接收到一个客户端对集群服务的请求后，它需要进行决策将请求调度至某一台后端主机进行响应。LVS的调度算法共有10种，按类别可以分为动态和静态两种类型。 静态调度算法静态调度算法调度时仅根据算法本身进行调度，不会考虑后端服务器的状态 RR（轮询）该方法不考虑别的因素，单纯以轮询的方式依次请求RS，因此处理会被均等地分发给所有服务器 WRR（加权轮询）与RR方法类似，但该方法引用了一个加权值来控制分发的比率。加权值越大，服务器被选择的概率就越高，因此为了让处理性能较高的服务器承受更多请求，只需增大其加权值即可 SH（源地址哈希）对客户端地址进行哈希计算，保存在Director的哈希表中，在一段时间内，同一个客户端 IP 地址的请求会被调度至相同的Realserver。sh算法的目的是实现session affinity（会话绑定），但是它也在一定程度上损害了负载均衡的效果。如果集群本身有session sharing 机制或者没有session信息，那么不需要使用sh算法 DH（目标地址哈希）和SH类似，DH将请求的目标地址进行哈希，将相同IP的请求发送至同一主机，dh机制的目的是，当Realserver为透明代理缓存服务器时，提高缓存的命中率。 动态调度算法动态调度算法在调度时，会根据后端Realserver的负载状态来决定调度选择，Realserver的负载状态通常由活动链接（active），非活动链接（inactive）和权重来计算。 LC（最小连接）该方法是将新的连接请求分发到当前连接数最少的服务器LVS根据overhead=active*256+inactive计算服务器的负载状态，每次选择overhead最小的服务器 WLC（加权最小连接）LVS根据overhead=(active*256+inactive)/weight来计算服务器负载，每次选择overhead 最小的服务器，它是LVS的默认调度算法 SED（最短期望延迟）该方法会选择响应速度最快的的那台服务器；它不对inactive状态的连接进行计算，根据overhead=(active+1)*256/weight计算服务器负载，选择overhead最小的服务器进行调度 NQ（永不排队）该方法会优先选择活动连接数为0的服务器；当有空闲服务器时，直接调度至空闲服务器，当没有空闲服务器时，使用SED算法进行调度 LBLC（基于本地的最小连接）它是DH方法的动态版本，在连接数没有超过加权值指定的值时，将选择同一台服务器，若是超过了加权值指定的值则选择其它服务器；当所有服务器的连接数都超过加权值指定的值时，将选择最终所选的那台服务器 LBLCR（带复制的基于本地的最小连接）与LBLC不同的是LVS将请求IP 映射至一个服务池中，使用dh算法调度请求至对应的服务池中，使用lc算法选择服务池中的节点，当服务池中的所有节点超载，使用lc算法从所有后端Realserver中选择一个添加至服务池中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LNMP环境搭建及WorkPress的安装]]></title>
      <url>%2F2015%2F12%2F02%2FLNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8AWorkPress%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[LNMP环境搭建安装nginx查看系统相关信息1234➜ ~ cat /etc/redhat-release CentOS release 6.7 (Final)➜ ~ uname -r2.6.32-573.7.1.el6.x86_64 安装pcre1234567➜ ~ rpm -qa pcre pcre-develpcre-7.8-7.el6.x86_64➜ ~ yum -y install pcre pcre-devel➜ ~ rpm -qa pcre pcre-devel pcre-devel-7.8-7.el6.x86_64pcre-7.8-7.el6.x86_64 安装openssl1➜ ~ yum -y install openssl-devel 安装nginx1234567891011➜ ~ useradd nginx -s /sbin/nologin -M➜ ~ id nginxuid=501(nginx) gid=501(nginx) groups=501(nginx)➜ ~ mkdir -pv /home/andy/tools➜ ~ cd /home/andy/tools ➜ tools wget -q http://nginx.org/download/nginx-1.6.3.tar.gz➜ tools tar xf nginx-1.6.3.tar.gz➜ tools cd nginx-1.6.3/➜ nginx-1.6.3 ./configure --prefix=/application/nginx-1.6.3 --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module ➜ nginx-1.6.3 make &amp;&amp; make install 创建软链接12➜ nginx-1.6.3 cd ..➜ tools ln -s /application/nginx-1.6.3 /application/nginx 启动nginx123➜ tools /application/nginx/sbin/nginx➜ tools ps -ef|grep nginx|grep -v grep➜ tools ss -lntup|grep nginx 安装mysql安装相关包cmake软件12345678➜ ~ cd tools➜ tools wget http://7xoagk.com1.z0.glb.clouddn.com/cmake-2.8.8.tar.gz➜ tools tar xf cmake-2.8.8.tar.gz ➜ tools cd cmake-2.8.8 ➜ cmake-2.8.8 ./configure➜ cmake-2.8.8 gmake➜ cmake-2.8.8 gmake install➜ cmake-2.8.8 cd .. 安装依赖包1➜ tools yum -y install ncurses-devel libaio-devel 安装mysql创建用户和组12➜ tools groupadd mysql➜ tools useradd mysql -s /sbin/nologin -M -g mysql 编译安装123456789101112131415161718192021➜ tools wget http://7xoagk.com1.z0.glb.clouddn.com/mysql-5.5.32.tar.gz➜ tools tar xf mysql-5.5.32.tar.gz➜ tools cd mysql-5.5.32➜ mysql-5.5.32 cmake . -DCMAKE_INSTALL_PREFIX=/application/mysql-5.5.32 \ -DMYSQL_DATADIR=/application/mysql-5.5.32/data \ -DMYSQL_UNIX_ADDR=/application/mysql-5.5.32/tmp/mysql.sock \ -DEXTRA_CHARSETS=gbk,gb2312,utf8,ascii \ -DENABLED_LOCAL_INFILE=ON \ -DWITH_INNOBASE_STORAGE_ENGINE=1 \ -DWITH_FEDERATED_STORAGE_ENGINE=1 \ -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \ -DWITHOUT_EXAMPLE_STORAGE_ENGINE=1 \ -DWITHOUT_PARTITION_STORAGE_ENGINE=1 \ -DWITH_FAST_MUTEXES=1 \ -DWITH_ZLIB=bundled \ -DENABLED_LOCAL_INFILE=1 \ -DWITH_READLINE=1 \ -DWITH_EMBEDDED_SERVER=1 \ -DWITH_DEBUG=0➜ mysql-5.5.32 make &amp;&amp; make install➜ mysql-5.5.32 ln -s /application/mysql-5.5.32 /application/mysql 初始化配置mysql查看默认模板配置文件123456➜ mysql-5.5.32 ll support-files/my*cnf-rw-r--r-- 1 root root 4759 Nov 13 16:30 support-files/my-huge.cnf-rw-r--r-- 1 root root 19809 Nov 13 16:30 support-files/my-innodb-heavy-4G.cnf-rw-r--r-- 1 root root 4733 Nov 13 16:30 support-files/my-large.cnf-rw-r--r-- 1 root root 4744 Nov 13 16:30 support-files/my-medium.cnf-rw-r--r-- 1 root root 2908 Nov 13 16:30 support-files/my-small.cnf 选择配置文件12➜ mysql-5.5.32 cd ..➜ tools cp mysql-5.5.32/support-files/my-small.cnf /etc/my.cnf 测试环境选小的，生产环境可以根据硬件选择，例如：support-files/my-innodb-heavy-4G.cnf 配置环境变量1234➜ tools echo 'export PATH=/application/mysql/bin:$PATH' &gt;&gt; /etc/profile➜ tools tail -1 /etc/profileexport PATH=/application/mysql/bin:$PATH➜ tools source /etc/profile 授权12345➜ tools ll /application/mysql/data total 4drwxr-xr-x 2 root root 4096 Nov 13 16:42 test➜ tools chown -R mysql.mysql /application/mysql/data➜ tools chmod -R 1777 /tmp/ 启动mysql123456789➜ tools cd /application/mysql/scripts ➜ scripts ./mysql_install_db --basedir=/application/mysql --datadir=/application/mysql/data --user=mysql➜ mysql cd /root/tools/mysql-5.5.32 ➜ mysql-5.5.32 /bin/cp support-files/mysql.server /etc/init.d/mysqld➜ tools sed -i 's#/usr/local/mysql#/application/mysql#g' /etc/init.d/mysqld➜ tools chmod +x /etc/init.d/mysqld➜ mysql-5.5.32 chmod +x /etc/init.d/mysqld ➜ mysql-5.5.32 /etc/init.d/mysqld startStarting MySQL.. [ OK ] 查看3306端口是否开启123➜ mysql-5.5.32 lsof -i :3306COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 24312 mysql 10u IPv4 444650 0t0 TCP *:mysql (LISTEN) 为mysql增加密码1➜ mysql-5.5.32 /application/mysql/bin/mysqladmin -u root password '111111' 登陆mysql1➜ mysql-5.5.32 mysql -uroot -p111111 设置开机自启动123➜ mysql-5.5.32 chkconfig mysqld on➜ mysql-5.5.32 chkconfig --list mysqldmysqld 0:off 1:off 2:on 3:on 4:on 5:on 6:off mysql的基本优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455mysql&gt; SELECT user,host FROM mysql.user;+------+--------------+| user | host |+------+--------------+| root | 127.0.0.1 || root | ::1 || | iZ288oaj8txZ || root | iZ288oaj8txZ || | localhost || root | localhost |+------+--------------+6 rows in set (0.00 sec)mysql&gt; DELETE FROM mysql.user WHERE user='';Query OK, 2 rows affected (0.00 sec)mysql&gt; DELETE FROM mysql.user WHERE host='www';Query OK, 0 rows affected (0.01 sec)mysql&gt; SELECT user,host FROM mysql.user;+------+--------------+| user | host |+------+--------------+| root | 127.0.0.1 || root | ::1 || root | iZ288oaj8txZ || root | localhost |+------+--------------+4 rows in set (0.00 sec)mysql&gt; DELETE FROM mysql.user WHERE host='::1';Query OK, 1 row affected (0.00 sec)mysql&gt; SELECT user,host FROM mysql.user;+------+--------------+| user | host |+------+--------------+| root | 127.0.0.1 || root | iZ288oaj8txZ || root | localhost |+------+--------------+3 rows in set (0.00 sec)mysql&gt; DROP DATABASE test;Query OK, 0 rows affected (0.01 sec)mysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec) 安装php安装PHP所需lib库12➜ tools yum -y install zlib-devel libxml2-devel libjpeg-devel libiconv-devel ➜ tools yum -y install freetype-devel libpng-devel gd-devel curl-devel libxslt-devel 安装libiconv-devel12345➜ tools wget http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.14.tar.gz➜ tools tar zxf libiconv-1.14.tar.gz➜ tools cd libiconv-1.14➜ libiconv-1.14 ./configure --prefix=/usr/local/libiconv➜ libiconv-1.14 make &amp;&amp; make install 安装mhash加密扩展库与mcrypt12➜ tools wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo➜ tools yum -y install mhash mhash-devel mcrypt 下载安装php123456789101112131415161718192021222324252627282930313233343536373839404142434445➜ tools wget http://7xoagk.com1.z0.glb.clouddn.com/php-5.3.27.tar.gz➜ tools tar xf php-5.3.27.tar.gz➜ tools cd php-5.3.27➜ php-5.3.27 ./configure \--prefix=/application/php5.3.27 \--with-mysql=/application/mysql \--with-iconv-dir=/usr/local/libiconv \--with-freetype-dir \--with-jpeg-dir \--with-png-dir \--with-zlib \--with-libxml-dir=/usr \--enable-xml \--disable-rpath \--enable-safe-mode \--enable-bcmath \--enable-shmop \--enable-sysvsem \--enable-inline-optimization \--with-curl \--with-curlwrappers \--enable-mbregex \--enable-fpm \--enable-mbstring \--with-mcrypt \--with-gd \--enable-gd-native-ttf \--with-openssl \--with-mhash \--enable-pcntl \--enable-sockets \--with-xmlrpc \--enable-zip \--enable-soap \--enable-short-tags \--enable-zend-multibyte \--enable-static \--with-xsl \--with-fpm-user=nginx \--with-fpm-group=nginx \--enable-ftp➜ php-5.3.27 ln -s /application/mysql/lib/libmysqlclient.so.18 /usr/lib64/➜ php-5.3.27 touch ext/phar/phar.phar➜ php-5.3.27 make &amp;&amp; make install➜ php-5.3.27 ln -s /application/php5.3.27/ /application/php 配置php引擎配置文件php.ini1➜ php-5.3.27 cp php.ini-production /application/php/lib/php.ini 配置php服务（fastcgi模式）配置文件php-fpm.conf1234➜ ~ cd /application/php/etc➜ etc wget http://7xoagk.com1.z0.glb.clouddn.com/php-fpm.conf➜ etc mkdir -pv /app/logs➜ etc cp /application/php5.3.27/var/log/php-fpm.log /app/logs 启动php服务1➜ etc /application/php/sbin/php-fpm 12345678➜ etc cd /application/nginx/conf/extra➜ extra vim blog.conf添加如下内容：location ~ .*\.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; 修改后，内容如下图所示12➜ extra ../../sbin/nginx -t➜ extra ../../sbin/nginx -s reload 创建测试文件12345➜ extra cd /application/nginx/html/blog➜ blog cat phpinfo.php &lt;?phpphpinfo();?&gt; 输入网址blog.magedu.org/phpinfo.php查看相应模块是否有安装经过验证nginx与php通信是没有问题的，下面测试php与mysql的连通情况编写测试脚本123456789➜ blog cat test_mysql.php&lt;?php $link_id=mysql_connect('localhost','root','111111') or mysql_error(); if($link_id)&#123; echo "mysql successful !"; &#125;else&#123; echo mysql_error(); &#125;?&gt; 输入网址blog.magedu.org/test_mysql.php，出现如下图所示内容，表示php与mysql连接没有问题删除测试文件1➜ blog rm -f phpinfo.php test_mysql.php 至此LNMP环境已经搭建成功 安装wordpress下载软件及权限设置12345678910111213➜ blog pwd/application/nginx/html/blog➜ blog wget https://cn.wordpress.org/wordpress-4.3.1-zh_CN.tar.gz➜ blog tar xf wordpress-4.3.1-zh_CN.tar.gz➜ blog rm -f wordpress-4.3.1-zh_CN.tar.gz➜ blog mv wordpress/* .➜ blog rm -rf wordpress/➜ blog cd ..➜ html chown -R root.root blog/ ➜ html find ./blog/ -type f |xargs chmod 644 ➜ html find ./blog/ -type d |xargs chmod 755➜ html mkdir blog/wp-content/uploads➜ html chown -R nginx.nginx blog/wp-content/uploads 为博客创建数据库1234➜ blog mysql -uroot -p111111mysql&gt; CREATE DATABASE wordpress;mysql&gt; GRANT ALL ON wordpress.* TO wordpress@"localhost" IDENTIFIED BY "111111";mysql&gt; FLUSH PRIVILEGES; 在浏览器中输入网址blog.magedu.com,出现以下页面 按照提示创建wp-config.php文件，并将文本内容写入文件中123➜ blog pwd/application/nginx/html/blog➜ blog vim wp-config.php 对WordPress进行设置 进入了博客后台，在里面就可以写文章了 看一下我们的博客首页长什么样子 设置伪静态在WordPress后台-设置-固定链接-自定义结构，输入下面的代码，最后保存更改即可。1/archives/%post_id%.html 编辑nginx配置文件，修改后内容如下12345678910111213141516171819➜ extra cat blog.conf server &#123; listen 80; server_name blog.magedu.org; root html/blog; location / &#123; index index.php index.html index.htm; try_files $uri $uri/ /index.php?$args; &#125; location ~ .*\.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; access_log logs/access_blog.log main; &#125;➜ extra ../../sbin/nginx -t➜ extra ../../sbin/nginx -s reload]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx常用功能的配置]]></title>
      <url>%2F2015%2F11%2F30%2Fnginx%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[nginx配置文件的简单优化12➜ ~ cd /application/nginx/conf ➜ conf cat nginx.conf 123456789101112131415161718192021222324252627282930313233343536➜ conf cat -n nginx.conf.base_name 1 worker_processes 1; 2 events &#123; 3 worker_connections 1024; 4 &#125; 5 6 http &#123; 7 include mime.types; 8 default_type application/octet-stream; 9 sendfile on; 10 keepalive_timeout 65; 11 server &#123; 12 listen 80; 13 server_name www.magedu.org; 14 location / &#123; 15 root html/www; 16 index index.html index.htm; 17 &#125; 18 &#125; 19 server &#123; 20 listen 80; 21 server_name bbs.magedu.org; 22 location / &#123; 23 root html/bbs; 24 index index.html index.htm; 25 &#125; 26 &#125; 27 server &#123; 28 listen 80; 29 server_name blog.magedu.org; 30 location / &#123; 31 root html/blog; 32 index index.html index.htm; 33 &#125; 34 &#125; 35 &#125; 123➜ conf sed -n '11,18p' nginx.conf.base_name &gt; extra/www.conf➜ conf sed -n '19,26p' nginx.conf.base_name &gt; extra/bbs.conf➜ conf sed -n '27,34p' nginx.conf.base_name &gt; extra/blog.conf 1234➜ conf ../sbin/nginx -tnginx: the configuration file /application/nginx-1.6.3/conf/nginx.conf syntax is oknginx: configuration file /application/nginx-1.6.3/conf/nginx.conf test is successful➜ conf ../sbin/nginx -s reload 虚拟主机别名的配置要实现的功能:当访问magedu.org时，内容与www.magedu.org是一样一样的 实现方式1➜ conf cat extra/www.conf 1➜ conf cat /etc/hosts 1234➜ conf ../sbin/nginx -t nginx: the configuration file /application/nginx-1.6.3/conf/nginx.conf syntax is oknginx: configuration file /application/nginx-1.6.3/conf/nginx.conf test is successful➜ conf ../sbin/nginx -s reload nginx的rewrite实现方式要实现的功能:当访问magedu.org时，将网页跳转到www.magedu.org 12345678910➜ conf vim extra/www.conf添加如下字段：server &#123; listen 80; server_name magedu.org; rewrite ^/(.*) http://www.magedu.org/$1 permanent; &#125;➜ conf ../sbin/nginx -t➜ conf ../sbin/nginx -s reload 企业应用场景Nginx的Rewrite功能在企业里的应用非常广泛： 可以调整用户浏览的URL，看起来更规范，合乎开发及产品人员的需求 为了让搜索引擎收录网站内容及更好的用户体验，企业会将动态URL地址伪装成静态地址提供服务 网站换新域名后，让旧的域名访问跳转到新的域名上 根据特殊变量、目录、客户端的信息进行URL跳转等。 显示nginx的状态Nginx软件的功能模块中有一个http_stub_status_module模块，它的功能是记录Nginx的基本访问状态信息，让使用者了解Nginx的工作状态，要想使用状态模块，在编译Nginx时必须增加http_stub_status_module可通过如下方法检查编译安装Nginx时是否设定支持上述模块：12345➜ conf ../sbin/nginx -Vnginx version: nginx/1.6.3built by gcc 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC) TLS SNI support enabledconfigure arguments: --prefix=/application/nginx-1.6.3 --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module 配置过程如下生成状态配置，并增加状态配置参数12345678910➜ conf cat extra/status.conf ##statusserver&#123; listen 80; server_name status.magedu.org; location / &#123; stub_status on; access_log off; &#125; &#125; 1➜ conf cat nginx.conf 1234➜ conf ../sbin/nginx -t nginx: the configuration file /application/nginx-1.6.3/conf/nginx.conf syntax is oknginx: configuration file /application/nginx-1.6.3/conf/nginx.conf test is successful➜ conf ../sbin/nginx -s reload 将status.magedu.org添加到hosts文件中,在此不赘述测试 Active connections: 2 –&gt;表示Nginx正在处理的活动连接数为2个 server accepts handled requests 15 15 14 第一个server表示从Nginx启动到现在共处理了15个连接 第二个accepts表示从Nginx启动到现在共成功创建15次握手 请求丢失数=（握手数-连接数），可以看出，本次状态显示没有丢失请求 第三个handled requests，表示总共处理了14次请求Reading: 0 Writing: 1 Waiting: 1Reading：Nginx读取到客户端的Header信息数Writing：Nginx返回给客户端的Header信息数Waiting：Nginx已经处理完等候下一次请求指令的驻留连接，在开启keepalived的情况下，这个值等于active-(reading+writing) 为Nginx增加错误日志编辑主配置文件nginx.conf，增加错误日志的配置1➜ conf cat nginx.conf 12➜ conf ../sbin/nginx -t➜ conf ../sbin/nginx -s reload 为Nginx增加访问日志配置过程编辑主配置文件1➜ conf cat nginx.conf 访问日志最好是基于虚拟主机的，以www为例1➜ conf cat extra/www.conf 重新加载12➜ conf ../sbin/nginx -t➜ conf ../sbin/nginx -s reload 查看日志1➜ conf tail -f ../logs/access_www.log Nginx访问日志轮询12➜ conf cd /server/scripts ➜ scripts cat cut_nginx_log.sh 123456789#!/bin/bashDateformat=`date +%Y%m%d`Basedir="/application/nginx"Nginxlogdir="$Basedir/logs"Logname="access_www"[ -d $Nginxlogdir ] &amp;&amp; cd $Nginxlogdir || exit 1[ -f $&#123;Logname&#125;.log ] || exit 1/bin/mv $&#123;Logname&#125;.log $&#123;Dateformat&#125;_$&#123;Logname&#125;.log$Basedir/sbin/nginx -s reload 添加定时任务123➜ scripts crontab -e00 00 * * * /bin/sh /server/scripts/cut_nginx_log.sh &gt; /dev/null 2&gt;&amp;1 12345➜ scripts crontab -l*/5 * * * * /usr/sbin/ntpdate time.nist.gov &gt; /dev/null 2&gt;&amp;1#########################00 00 * * * /bin/sh /server/scripts/cut_nginx_log.sh &gt; /dev/null 2&gt;&amp;1 更多内容可参考nginx官方文档之ngx_http_log_module模块]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx中虚拟主机的配置]]></title>
      <url>%2F2015%2F11%2F27%2Fnginx%E4%B8%AD%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[在上篇博文中我们搭建了nginx平台，下面将进一步介绍，nginx中虚拟主机的配置,由于基于IP地址的虚拟主机很少用到，所以这里只介绍了基于域名和基于端口的虚拟主机的配置过程 搭建基于域名的虚拟机主机1234➜ conf pwd/application/nginx/conf➜ conf egrep -v "#|^$" nginx.conf.default &gt; nginx.conf➜ conf vim nginx.conf 修改后内容如下图所示： 创建站点目录及页面文件123456789101112➜ conf mkdir -p ../html/&#123;www,bbs&#125;➜ conf tree ../html../html├── 50x.html├── bbs├── index.html└── www➜ conf echo "www.magedu.org" &gt; ../html/www/index.html➜ conf echo "bbs.magedu.org" &gt; ../html/bbs/index.html➜ conf cat ../html/&#123;www,bbs&#125;/index.html www.magedu.orgbbs.magedu.org 重启nginx，使配置生效：1234➜ conf /application/nginx/sbin/nginx -t --&gt;检查语法nginx: the configuration file /application/nginx-1.6.3/conf/nginx.conf syntax is oknginx: configuration file /application/nginx-1.6.3/conf/nginx.conf test is successful➜ conf /application/nginx/sbin/nginx -s reload 编辑host文件1234➜ conf cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain654.186.180.32 www.magedu.org bbs.magedu.org 尝试访问站点1234➜ conf curl www.magedu.comwww.magedu.org➜ conf curl bbs.magedu.combbs.magedu.org 成功 在windows上修改host文件，如下图所示使用快捷键调出运行命令窗口在弹出窗口中找到etc文件夹找到host文件编辑host文件，保存退出 使用浏览器访问站点，测试可以成功显示页面，如下图 搭建基于端口的虚拟机主机基于端口的虚拟主机在生产环境中并不多见，但偶尔也会用到，一般是为公司内部人员提供访问的，如OA系统，网站程序的后台、 CMS发布后台、MySql的Web客户端PHPmyadmin等，使用特殊端口是从安全上考虑的。相关配置过程如下修改监听端口12➜ conf cp nginx.conf nginx.conf.base_name➜ conf cat nginx.conf 重启nginx123456789➜ conf ../sbin/nginx -tnginx: the configuration file /application/nginx-1.6.3/conf/nginx.conf syntax is oknginx: configuration file /application/nginx-1.6.3/conf/nginx.conf test is successful➜ conf ../sbin/nginx -s reload➜ conf netstat -lntup|grep nginxtcp 0 0 0.0.0.0:8001 0.0.0.0:* LISTEN 1320/nginx tcp 0 0 0.0.0.0:8002 0.0.0.0:* LISTEN 1320/nginx tcp 0 0 0.0.0.0:8003 0.0.0.0:* LISTEN 1320/nginx 验证：在使用crul命令验证时，第一次没有成功，按照上一篇博文中的方法在EC2的控制台中新增‘所有TCP规则’即可。12345678➜ conf curl www.magedu.org:8001 www.magedu.org➜ conf curl www.magedu.org:8001www.magedu.org➜ conf curl bbs.magedu.org:8002bbs.magedu.org➜ conf curl blog.magedu.org:8003blog.magedu.org 下面将域名都改为www.magedu.org,再次测试,可以成功显示1➜ conf cat nginx.conf 12345678910➜ conf /application/nginx/sbin/nginx -tnginx: the configuration file /application/nginx-1.6.3/conf/nginx.conf syntax is oknginx: configuration file /application/nginx-1.6.3/conf/nginx.conf test is successful➜ conf /application/nginx/sbin/nginx -s reload➜ conf curl http://www.magedu.org:8001 www.magedu.org➜ conf curl http://www.magedu.org:8002 bbs.magedu.org➜ conf curl http://www.magedu.org:8003blog.magedu.org 我以前都是在VMWARE虚拟机中做实验，现在第一次使用AWS，难免会遇到许多坑，但是我们现在遇到的问题早就有人遇到过，我们踩过的坑里都是前人的脚印，只要遇到问题多思考，多上Google，多与身边的朋友交流就可以了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx的特性以及安装]]></title>
      <url>%2F2015%2F11%2F24%2Fnginx%E7%9A%84%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[nginx的特性 模块化设计，有较好的扩展性，方便开发人员为其设计第三方模块，对功能进行扩展；nginx早期的版本不支持模块动态装卸载（编译时只能静态编译进nginx，而且随nginx的启动而启动），但是淘宝研发的Tengine是支持模块动态装卸载机制的； 高可靠性，它有一个主控进程（master），主控进程主要负责解析配置文件并启动多个子进程（worker），而worker进程才是真正响应用户请求的进程； 低内存消耗，因为它是由一个线程响应n个请求，所以其内存消耗非常低； 支持热部署，指的是不停机更新配置文件、日志文件的滚动或者升级程序版本； 支持事件驱动机制、支持异步IO（AIO）、支持内存映射机制（mmap）。 nginx的基本功能 它是一个静态资源的web服务器，能缓存打开的文件描述符； 它支持http、smtp、pop3协议的反向代理服务器； 它支持缓存加速和负载均衡机制； 它支持FastCGI、uWSGI等； 它支持非DSO机制的模块化，支持过滤器，支持SSI机制及图像的大小调整； 支持SSL。 nginx的扩展功能 支持基于域名、端口与IP的虚拟主机； 支持keepalive； 支持平滑升级； 支持定制访问日志，支持使用日志缓冲区提供日志存储性能； 支持url rewrite； 支持路径别名； 支持基于IP及用户的访问控制； 支持速率限制与并发数限制。 nginx的工作模式基于非阻塞与事件驱动机制，由一个master进程生成多个worker线程，每个worker响应n个请求。 nginx的模块类型 核心模块 标准http模块（Standard HTTP modules） 可选的http模块（Optional HTTP modules） 邮件模块（Mail modules） 第三方模块（3rd party modules） nginx的安装查看系统相关信息1234➜ ~ cat /etc/redhat-release CentOS release 6.7 (Final)➜ ~ uname -r2.6.32-573.7.1.el6.x86_64 安装pcre1234567➜ ~ rpm -qa pcre pcre-develpcre-7.8-7.el6.x86_64➜ ~ yum -y install pcre pcre-devel➜ ~ rpm -qa pcre pcre-devel pcre-devel-7.8-7.el6.x86_64pcre-7.8-7.el6.x86_64 安装openssl1➜ ~ yum -y install openssl-devel 安装nginx1234567891011➜ ~ useradd nginx -s /sbin/nologin -M➜ ~ id nginxuid=501(nginx) gid=501(nginx) groups=501(nginx)➜ ~ mkdir -pv /home/andy/tools➜ ~ cd /home/andy/tools ➜ tools wget -q http://nginx.org/download/nginx-1.6.3.tar.gz➜ tools tar xf nginx-1.6.3.tar.gz➜ tools cd nginx-1.6.3/➜ nginx-1.6.3 ./configure --prefix=/application/nginx-1.6.3 --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module ➜ nginx-1.6.3 make &amp;&amp; make install 注意：nginx虽然是模块化设计，有较好的扩展性但其并不支持模块的动态装卸载，然而由淘宝开发的Tengine则是支持的。 在执行./configure时出现错误12345checking for OS + Linux 2.6.32-573.7.1.el6.x86_64 x86_64checking for C compiler ... not found./configure: error: C compiler cc is not found 安装开发组件后问题解决1➜ ~ yum -y groupinstall "Development tools" 创建软链接12➜ nginx-1.6.3 cd ..➜ tools ln -s /application/nginx-1.6.3 /application/nginx 启动nginx12345678➜ tools /application/nginx/sbin/nginx➜ tools ps -ef|grep nginx|grep -v greproot 1320 1 0 08:43 ? 00:00:00 nginx: master process /application/nginx/sbin/nginxnginx 1323 1320 0 08:43 ? 00:00:00 nginx: worker process ➜ tools ss -lntup|grep nginxtcp LISTEN 0 128 *:80 *:* users:(("nginx",1320,6),("nginx",1323,6)) 检查是否能够正常访问1234567891011121314151617181920212223242526➜ tools curl 127.0.0.1&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 尝试使用浏览器访问，我这里使用的是AWS，需要做一些配置才可以正常访问 选择实例，进入它的安全组 选择入站，按照图示添加相应规则 再次访问页面，可以正常显示 附：nginx官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux系统下svn的安装]]></title>
      <url>%2F2015%2F10%2F25%2FLinux%E7%B3%BB%E7%BB%9F%E4%B8%8Bsvn%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[简介svn是一个跨平台的版本控制系统，它管理着随时间改变的各种数据，这些数据都是保存在中央资料档案库中的；svn会备份并记录每个文件的修改更新变动，这样就可以很方便地将文件恢复到任一时间点的版本。 安装配置Svn服务准备操作系统并查看系统环境123456➜ ~ cat /etc/redhat-release CentOS release 5.10 (Final)➜ ~ uname -mx86_64➜ ~ uname -r2.6.18-371.11.1.el5 安装svn首先检查svn是否已安装：123➜ ~ rpm -qa subversionsubversion-1.6.11-12.el5_10subversion-1.6.11-12.el5_10 若未安装则执行以下命令：1➜ ~ yum -y install subversion 配置并启动svn建立svn数据存储根目录（svndata）及用户、密码、权限目录（svnpasswd）12➜ ~ mkdir -p /application/svndata➜ ~ mkdir -p /application/svnpasswd 启动svn1➜ ~ svnserve -d -r /application/svndata 查看svn是否启动1234567➜ ~ ps -ef|grep svnroot 16969 1 0 13:38 ? 00:00:00 svnserve -d -r /application/svndata➜ ~ netstat -lntup | grep 3690tcp 0 0 0.0.0.0:3690 0.0.0.0:* LISTEN 16969/svnserve ➜ ~ lsof -i :3690COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsvnserve 16969 root 3u IPv4 147101 0t0 TCP *:svn (LISTEN) svn相关操作建立项目版本库以创建项目sadoc为例：1➜ ~ svnadmin create /application/svndata/sadoc 调整svn配置文件及权限文件配置允许用户andy读写访问123➜ ~ cd /application/svndata/sadoc/conf➜ conf cp svnserve.conf svnserve.conf.bak➜ conf vim svnserve.conf 修改如下内容：1234anon-access = none &lt;--是否允许匿名访问auth-access = write &lt;--访问权限password-db = /application/svnpasswd/passwd &lt;--此处一般无需修改，保持默认即可；在此为了方便统一管理于是做了相应修改authz-db = /application/svnpasswd/authz 查看修改的内容：1➜ conf diff svnserve.conf.bak svnserve.conf 将密码认证文件模板拷贝到svnpasswd目录下1➜ conf cp authz passwd /application/svnpasswd 修改文件权限：12➜ conf cd /application/svnpasswd➜ svnpasswd chmod 700 * 编辑配置passwd文件,在[users]下添加相关信息：1andy = andy123 注意： 等号前为svn账号，等号后为svn密码，密码是明文的，要注意密码权限 更改svnserver.conf后需要重启svn，更改authz或passwd文件后则无需重启svn 编辑配置authz文件,在[groups]下添加相关信息：12[sadoc:/]andy = rw 注意： 权限配置文件中出现的用户名必须已在用户配置文件中定义 对权限配置文件的修改立即生效，不必重启svn 格式说明：1234567891011121314151617181920212223[groups]# harry_and_sally = harry,sally# harry_sally_and_joe = harry,sally,&amp;joe一个用户组可以包含一个或多个用户，用户间以逗号分隔。# [repository:/baz/fuz]# @harry_and_sally = rw# * = r[sadoc:/]andy = rw[&lt;版本库&gt;：/项目/目录]@&lt;用户组名&gt;=&lt;权限&gt;&lt;用户名&gt;=&lt;权限&gt;其中方框内部可以有多种写法：[/]表示根目录及以下，根目录是svnserve启动时指定的，我们指定为/application/svndata，[/]就是表示对全部版本库设置权限[repos:/]表示对版本库repos设置权限[repos:/sadoc]表示对版本库repos中的sadoc项目设置权限[repos:/sadoc/andy]表示对版本库repos中的sadoc项目的andy目录设置权限权限主体可以是用户组、用户或*，用户组在前面加@，*表示全部用户权限可以是w、r、wr和空，空表示无任何权限authz中每个参数都要顶格写，开头不能有空格 重启svn12➜ svnpasswd pkill svnserve➜ svnpasswd svnserve -d -r /application/svndata]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux系统文件删除原理]]></title>
      <url>%2F2015%2F10%2F25%2FLinux%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[原理如下图所示： Linux是通过link的数量来控制文件删除的；一般来说，每个文件都有2个link计数器：i_link和i_count。i_link是文件的硬链接数（磁盘引用计数器）i_count是文件被进程调用数（内存引用计数）只有当i_link和i_count都为0时，文件才是真正地被删除了；rm命令删除的只是文件的i_link数。]]></content>
    </entry>

    
  
  
</search>
